{"index":{"title":"welcome to my digital garden","links":["tags"],"tags":[],"content":"数字花园 是我的一种全新的尝试，既然叫做数字花园，那么我希望它应该向阳而肆意生长，摆脱苦恼与烦闷！\n开始浏览我的数字花园tags\n搭建数字花园（Quartz）官方文档 Welcome to Quartz 4 (jzhao.xyz)\n\n我的数字花园部署结构\n\n私有仓库（quartz-obsidian） ⇒ git actions部署pages ⇒ 公开仓库（chyuhung.github.io）\n\ngit actions 代码\n\nname: Deploy Quartz site to GitHub Pages\n \non:\n  push:\n    branches:\n      - v4\n \npermissions:\n  contents: read\n  pages: write\n  id-token: write\n \nconcurrency:\n  group: &quot;pages&quot;\n  cancel-in-progress: false\n \njobs:\n  build:\n    runs-on: ubuntu-22.04\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0 # Fetch all history for git info\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 18.14\n      - name: Install Dependencies\n        run: npm ci\n      - name: Build Quartz\n        run: npx quartz build\n      - name: Deploy to GitHub Pages\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.ID_RSA_HUGO_DEPLOY }}\n          external_repository: chyuhung/chyuhung.github.io\n          publish_branch: main\n          publish_dir: ./public\n          commit_message: ${{ github.event.head_commit.message }}\n\nkey配置\n\n使用ssh-keygen生成一对公钥和密钥，在代码仓库（quartz-obsidian）secrets中添加私钥，在pages仓库（chyuhung.github.io）添加公钥"},"tags":{"title":"tags","links":["基础技能/基础技能","自动化和编程/自动化和编程","云计算和虚拟化/云计算和虚拟化","应用部署和容灾/应用部署和容灾","监控和日志管理/监控和日志管理","安全和权限管理/安全和权限管理","网络和存储管理/网络和存储管理","故障排除和性能优化/故障排除和性能优化","文档和沟通能力/文档和沟通能力"],"tags":[],"content":"\n\n基础技能\n\n操作系统（如 Linux、Unix、Windows）的基本原理和命令行操作\n网络协议和网络基础知识\n编程基础（如 Python、Shell、Perl）\n\n\n\n自动化和编程\n\n自动化工具（如 Ansible、Chef、Puppet）\n脚本编程和编写自动化脚本\n版本控制系统（如 Git、SVN）\n\n\n\n云计算和虚拟化\n\n云计算基础概念和服务模型（如 IaaS、PaaS、SaaS）\n虚拟化技术（如 VMware、KVM、Docker）\n容器编排和管理工具（如 Kubernetes）\n\n\n\n应用部署和容灾\n\nWeb 服务器和应用服务器的部署和配置（如 Nginx、Apache、Tomcat）\n高可用性和容灾技术（如负载均衡、故障转移、备份恢复）\n\n\n\n监控和日志管理\n\n监控系统的搭建和配置（如 Zabbix、Prometheus）\n日志管理和分析工具（如 ELK Stack、Splunk）\n\n\n\n安全和权限管理\n\n系统安全和漏洞管理\n访问控制和权限管理（如 LDAP、RBAC）\n防火墙和网络安全配置\n\n\n\n网络和存储管理\n\n网络设备的配置和管理\n存储管理和数据备份策略\n数据库管理（如 MySQL、PostgreSQL、MongoDB）\n\n\n\n故障排除和性能优化\n\n系统故障排查和调优\n性能监测和性能优化技术\n容量规划和资源管理\n\n\n\n文档和沟通能力\n\n技术文档编写和维护\n团队协作和沟通能力\n问题解决和故障处理技巧\n\n\n"},"云计算和虚拟化/Openstack-Train安装":{"title":"Openstack-Train安装","links":[],"tags":["云计算和虚拟化"],"content":"基础环境准备\n节点规划\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称描述管理IP（虚拟机）内部IP配置ctl01控制节点10.191.101.128/24192.168.80.128/242C2Gcompute01计算节点10.191.101.129/24192.168.80.129/242C4Gneutron01网络节点10.191.101.130/24192.168.80.130/242C2Gcinder01存储节点10.191.101.131/24192.168.80.131/242C2G(新增)compute02计算节点(win)-192.168.80.139/242C2G\n系统版本\nCentOS Linux release 7.6.1810 (Core)\ncat /etc/redhat-release\n自动补全\nyum install bash-completion\n下载包到本地\nwget -erobots=off -m -c -np --reject=html,gif,A,D -nH --cut-dirs=4 -P /opt/ http://mirrors.aliyun.com/centos/7/cloud/x86_64/openstack-train/\n配置本地YUM\n/etc/yum.repos.d/Openstack-Train.repo\n[Openstack-Train]\nname=Openstack-Train\nbaseurl=file:///opt/openstack-train/\nenabled=1\ngpgcheck=0\n挂载光盘\nmkdir /mnt/cdrom\nmount -t iso9660 -o loop /dev/cdrom /mnt/cdrom\ncat /etc/yum.repos.d/CentOS-iso.repo\n[CenOS-iso]\nname=CenOS-iso\nbaseurl=file:///mnt/cdrom/\nenabled=1\ngpgcheck=0\n写入配置文件，/etc/fstab\n/dev/cdrom /mnt/cdrom iso9660 defaults,loop 0 0\n启用YUM缓存\n[root@centos7 ~]# cat /etc/yum.conf\n[main]\ncachedir=/var/cache/yum/$basearch/$releasever\nkeepcache=1\n基础工具安装\nyum -y install net-tools\nyum -y install wget\n更改主机名\n\n不同角色不同名字分别设置\n\nhostnamectl set-hostname ctl01\nhostnamectl set-hostname compute01\nhostnamectl set-hostname neutron01\nhostnamectl set-hostname cinder01\n配置网络\n由于使用VMware Workstation进行部署，需要更改原有的网络配置\n主机管理网络\n\n\n\n注意NAT设置中，设置的网关IP与本机对应虚拟网卡IP不可一致，否则无法正常与外网通信，该问题由于VMware Workstation虚拟实现的NAT和DHCP造成，网关是虚拟机的交换设备，本机vmnet8和对应ip则作为通信载体，不可使用同一个IP\n\n相关参考：https://blog.51cto.com/u_13648313/2164309\nNAT配置网关为10.191.101.2\n\n\n主机对应网卡地址则配置为10.191.101.1，此外需指定配置DNS Server，否则虚拟主机无法解析域名，如果部分虚拟机无法正常获取DNS Server地址，亦可在虚拟机网卡配置中写入DNS Server\n\n\n控制节点\ncat /etc/sysconfig/network-scripts/ifcfg-ens33\nTYPE=Ethernet\nBOOTPROTO=static\nDEFROUTE=yes\nNAME=ens33\nDEVICE=ens33\nONBOOT=yes\nIPADDR=10.191.101.128\nNETMASK=255.255.255.0\nGATEWAY=10.191.101.2\n\n计算节点\ncat /etc/sysconfig/network-scripts/ifcfg-ens33\nTYPE=Ethernet\nBOOTPROTO=static\nDEFROUTE=yes\nNAME=ens33\nDEVICE=ens33\nONBOOT=yes\nIPADDR=10.191.101.129\nNETMASK=255.255.255.0\nGATEWAY=10.191.101.2\n\n虚拟机流量网络\n\n\n控制节点\ncp /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-ens34\ncat /etc/sysconfig/network-scripts/ifcfg-ens34\nTYPE=Ethernet\nBOOTPROTO=static\nDEFROUTE=yes\nNAME=ens34\nDEVICE=ens34\nONBOOT=yes\nIPADDR=192.168.80.128\nNETMASK=255.255.255.0\n计算节点\ncat /etc/sysconfig/network-scripts/ifcfg-ens34\nTYPE=Ethernet\nBOOTPROTO=static\nDEFROUTE=yes\nNAME=ens34\nDEVICE=ens34\nONBOOT=yes\nIPADDR=192.168.80.129\nNETMASK=255.255.255.0\n新增win compute对网络的调整（可选）\n在hyperv交换机管理新增一个内部交换机\n\n在宿主机（本机）确认创建的交换机信息\n\n在workstation中修改或创建桥接网络到hyperv虚拟交换机\n\n调整其他openstack节点，例如控制节点，连接到桥接hyperv交换机的网卡\n\n在hyperv虚拟机（计算节点）中配置与其他节点指定网卡同网段地址测试\n\n测试网络连接\n\n关闭selinux\nsed -i &#039;s|SELINUX=enforcing|SELINUX=disabled|&#039; /etc/selinux/config\n连接数配置\necho &#039;* soft nofile 65530\n* hard nofile 65530\n* soft nproc 65530\n* hard nproc 65530&#039;&gt;&gt;/etc/security/limits.conf\n关闭防火墙\nsystemctl disable firewalld\nsystemctl stop firewalld\n关闭NetworkManager\nsystemctl disable NetworkManager\nsystemctl stop NetworkManager\nHOSTS文件配置\necho &#039;10.191.101.128 ctl01\n10.191.101.129 compute01\n10.191.101.130 neutron01\n10.191.101.131 cinder01\n10.191.101.140 ceph01&#039;&gt;&gt;/etc/hosts\nNTP时钟同步\nyum install -y chrony\n计算节点将server修改为控制节点ip\necho &quot;server 10.191.101.128 iburst&quot; &gt;&gt; /etc/chrony.conf\n同步时间\nsystemctl enable chronyd.service\nsystemctl restart chronyd.service\nchronyc sources\n数据库\n\nMost OpenStack services use an SQL database to store information.\n\n安装软件包\nyum install mariadb mariadb-server python2-PyMySQL\n创建并编辑 /etc/my.cnf.d/openstack.cnf\n[mysqld]\nbind-address = 10.191.101.128\ndefault-storage-engine = innodb\ninnodb_file_per_table\nmax_connections = 4096\ncollation-server = utf8_general_ci\ncharacter-set-server = utf8\n启动数据库，配置开机启动\nsystemctl enable mariadb.service\nsystemctl restart mariadb.service\n初始化数据库,本次测试配置密码为Abc-1234\nmysql_secure_installation\n（可选）配置远程root登录\nWelcome to the MariaDB monitor.  Commands end with ; or \\g.\nYour MariaDB connection id is 16\nServer version: 10.3.20-MariaDB MariaDB Server\n \nCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.\n \nType &#039;help;&#039; or &#039;\\h&#039; for help. Type &#039;\\c&#039; to clear the current input statement.\n \nMariaDB [(none)]&gt; use mysql;\nReading table information for completion of table and column names\nYou can turn off this feature to get a quicker startup with -A\n \nDatabase changed\nMariaDB [mysql]&gt; select host,user from user;\n+-----------+------+\n| host      | user |\n+-----------+------+\n| 127.0.0.1 | root |\n| ::1       | root |\n| ctl01     | root |\n| localhost | root |\n+-----------+------+\n4 rows in set (0.000 sec)\n \nMariaDB [mysql]&gt; GRANT ALL PRIVILEGES ON *.* TO &#039;root&#039;@&#039;%&#039; IDENTIFIED BY &#039;Abc-1234&#039; WITH GRANT OPTION;\nQuery OK, 0 rows affected (0.000 sec)\n \nMariaDB [mysql]&gt; select host,user from user;\n+-----------+------+\n| host      | user |\n+-----------+------+\n| %         | root |\n| 127.0.0.1 | root |\n| ::1       | root |\n| ctl01     | root |\n+-----------+------+\n4 rows in set (0.000 sec)\n \nMariaDB [mysql]&gt; FLUSH PRIVILEGES;\nQuery OK, 0 rows affected (0.000 sec)\n \n消息队列\n\nOpenStack uses a message queue to coordinate operations and status information among services.\n\n安装\nyum install rabbitmq-server\n开机启动\nsystemctl enable rabbitmq-server.service\nsystemctl restart rabbitmq-server.service\n新增openstack用户\nrabbitmqctl add_user openstack Abc-1234\n为用户配置权限\nrabbitmqctl set_permissions openstack &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;\n检查状态\nsystemctl status rabbitmq-server.service\nnetstat -nltp | grep 5672\nMemcached\n\nThe Identity service authentication mechanism for services uses Memcached to cache tokens.\n\n安装\nyum install memcached python-memcached\n配置/etc/sysconfig/memcached，允许访问的ip\n\nConfigure the service to use the management IP address of the controller node. This is to enable access by other nodes via the management network\n\nPORT=&quot;11211&quot;\nUSER=&quot;memcached&quot;\nMAXCONN=&quot;1024&quot;\nCACHESIZE=&quot;64&quot;\nOPTIONS=&quot;-l 127.0.0.1,::1,ctl01&quot;\n配置开机启动\nsystemctl enable memcached.service\nsystemctl restart memcached.service\n检查状态\nsystemctl status memcached.service\nnetstat -nltup | grep 11211\nEtcd\n\nOpenStack services may use Etcd, a distributed reliable key-value store for distributed key locking, storing configuration, keeping track of service live-ness and other scenarios.\n\n安装\nyum install etcd\n备份和修改配置\ncp -a /etc/etcd/etcd.conf{,.bak}\n\nset the ETCD_INITIAL_CLUSTER, ETCD_INITIAL_ADVERTISE_PEER_URLS, ETCD_ADVERTISE_CLIENT_URLS, ETCD_LISTEN_CLIENT_URLS to the management IP address of the controller node to enable access by other nodes via the management network\n\n#[Member]\nETCD_DATA_DIR=&quot;/var/lib/etcd/default.etcd&quot;\nETCD_LISTEN_PEER_URLS=&quot;http://10.191.101.128:2380&quot;\nETCD_LISTEN_CLIENT_URLS=&quot;http://10.191.101.128:2379&quot;\nETCD_NAME=&quot;ctl01&quot;\n#[Clustering]\nETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;http://10.191.101.128:2380&quot;\nETCD_ADVERTISE_CLIENT_URLS=&quot;http://10.191.101.128:2379&quot;\nETCD_INITIAL_CLUSTER=&quot;ctl01=http://10.191.101.128:2380&quot;\nETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster-01&quot;\nETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;\n配置开机启动和检查状态\nsystemctl enable etcd\nsystemctl restart etcd\nsystemctl status etcd\n密码规划\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPassword nameDescriptionKeyDatabase password (no variable used)Root password for the databaseAbc-1234ADMIN_PASSPassword of user adminAbc-1234CINDER_DBPASSDatabase password for the Block Storage serviceAbc-1234CINDER_PASSPassword of Block Storage service user cinderAbc-1234DASH_DBPASSDatabase password for the DashboardAbc-1234DEMO_PASSPassword of user demoAbc-1234GLANCE_DBPASSDatabase password for Image serviceAbc-1234GLANCE_PASSPassword of Image service user glanceAbc-1234KEYSTONE_DBPASSDatabase password of Identity serviceAbc-1234METADATA_SECRETSecret for the metadata proxyAbc-1234NEUTRON_DBPASSDatabase password for the Networking serviceAbc-1234NEUTRON_PASSPassword of Networking service user neutronAbc-1234NOVA_DBPASSDatabase password for Compute serviceAbc-1234NOVA_PASSPassword of Compute service user novaAbc-1234PLACEMENT_PASSPassword of the Placement service user placementAbc-1234RABBIT_PASSPassword of RabbitMQ user openstackAbc-1234\nMinimal deployment for Train\n\n本次安装train版本，其他版本可参考官网相关手册，最小化的train版本安装必须包含下面的这些服务，逐步开始\n\n\nAt a minimum, you need to install the following services. Install the services in the order specified below\n\n\n\nIdentity service – keystone installation for Train\nhttps://docs.openstack.org/keystone/train/install/\n\n\nImage service – glance installation for Train\nhttps://docs.openstack.org/glance/train/install/\n\n\nPlacement service – placement installation for Train\nhttps://docs.openstack.org/placement/train/install/\n\n\nCompute service – nova installation for Train\nhttps://docs.openstack.org/nova/train/install/\n\n\nNetworking service – neutron installation for Train\nhttps://docs.openstack.org/neutron/train/install/\n\n\n\nWe advise to also install the following components after you have installed the minimal deployment services\n\n\n\nDashboard – horizon installation for Train\nhttps://docs.openstack.org/horizon/train/install/\n\n\nBlock Storage service – cinder installation for Train\nhttps://docs.openstack.org/cinder/train/install/\n\n\nKeystone\n\nThe OpenStack Identity service provides a single point of integration for managing authentication, authorization, and a catalog of services.\n\n先决条件\n在配置 OpenStack 身份认证服务前，必须创建一个数据库和管理员令牌\n登录数据库\nmysql -u root -p\n创建和配置数据表\nCREATE DATABASE keystone;\n对keystone数据库授予恰当的权限\nGRANT ALL PRIVILEGES ON keystone.* TO &#039;keystone&#039;@&#039;localhost&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\nGRANT ALL PRIVILEGES ON keystone.* TO &#039;keystone&#039;@&#039;%&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\n配置组件\n安装组件\nyum install openstack-keystone httpd mod_wsgi\n备份和配置/etc/keystone/keystone.conf\ncp /etc/keystone/keystone.conf{,.bak}\ncat /etc/keystone/keystone.conf|egrep -v &quot;#|^$&quot;\n[database]\nconnection = mysql+pymysql://keystone:Abc-1234@ctl01/keystone\n[token]\nprovider = fernet\n填充数据库并验证\nsu -s /bin/sh -c &quot;keystone-manage db_sync&quot; keystone\nmysql keystone -e &#039;show tables&#039;\nERROR 1045 (28000): Access denied for user &#039;root&#039;@&#039;localhost&#039; (using password: NO)\n报错处理，备份和修改配置\ncp /etc/my.cnf.d/mariadb-server.cnf{,.bak}\ncat /etc/my.cnf.d/mariadb-server.cnf|grep -vi &quot;^$\\|#&quot;\n[mysqld]\nskip-grant-tables\n重启数据库检查\nsystemctl restart mariadb.service\nmysql keystone -e &#039;show tables&#039;\n+------------------------------------+\n| Tables_in_keystone                 |\n+------------------------------------+\n初始化Fernet keys\nkeystone-manage fernet_setup --keystone-user keystone --keystone-group keystone\nkeystone-manage credential_setup --keystone-user keystone --keystone-group keystone\n引导身份服务\nkeystone-manage bootstrap --bootstrap-password Abc-1234 \\\n--bootstrap-admin-url http://ctl01:5000/v3/ \\\n--bootstrap-internal-url http://ctl01:5000/v3/ \\\n--bootstrap-public-url http://ctl01:5000/v3/ \\\n--bootstrap-region-id RegionOne\n配置Apache HTTP服务器\n配置servername为控制节点\ncat /etc/httpd/conf/httpd.conf|grep &quot;ServerName&quot;\n# ServerName gives the name and port that the server uses to identify itself.\nServerName ctl01\n创建配置文件软连接\nln -s /usr/share/keystone/wsgi-keystone.conf /etc/httpd/conf.d/\n配置开机启动和检查状态\nsystemctl enable httpd.service\nsystemctl restart httpd.service\nsystemctl status httpd.service\n为admin用户添加环境变量\ncat &gt;&gt; ~/admin-openrc &lt;&lt; EOF\nexport OS_USERNAME=admin\nexport OS_PASSWORD=Abc-1234\nexport OS_PROJECT_NAME=admin\nexport OS_USER_DOMAIN_NAME=Default\nexport OS_PROJECT_DOMAIN_NAME=Default\nexport OS_AUTH_URL=http://ctl01:5000/v3\nexport OS_IDENTITY_API_VERSION=3\nEOF\n创建域，项目，用户和角色\n创建域的方法\nsource admin-openrc\nopenstack domain create --description &quot;An Example Domain&quot; example\n-bash: openstack: command not found\n报错处理，安装openstack客户端\nyum install python-openstackclient\n创建service项目\nopenstack project create --domain default --description &quot;Service Project&quot; service\n创建myproject项目\nopenstack project create --domain default --description &quot;Demo Project&quot; myproject\n创建myuser用户，此处密码使用Abc-1234(—password-prompt为交互式,—password+密码为非交互式)\nopenstack user create --domain default --password-prompt myuser\n创建myrole角色\nopenstack role create myrole\n查看角色\n[root@ctl01 ~]# openstack role list\n+----------------------------------+--------+\n| ID                               | Name   |\n+----------------------------------+--------+\n| 4bd9bb8d39564e99abefb2d576b72f7e | member |\n| 5171abb30ef24b11b31f58f5cffe81a1 | myrole |\n| 8e1a7c8613a045949fbc1ecdb14dcfe7 | reader |\n| bfc42249d4504d908ea2c416ce655a4f | admin  |\n+----------------------------------+--------+\n\n将角色添加到myproject项目和myuser用户\nopenstack role add --project myproject --user myuser myrole\n验证\n取消环境变量\nunset OS_AUTH_URL OS_PASSWORD\nadmin用户请求令牌验证\nopenstack --os-auth-url http://ctl01:5000/v3 \\\n--os-project-domain-name Default \\\n--os-user-domain-name Default \\\n--os-project-name admin \\\n--os-username admin token issue\nmyuser用户请求令牌验证\nopenstack --os-auth-url http://ctl01:5000/v3 \\\n--os-project-domain-name Default \\\n--os-user-domain-name Default \\\n--os-project-name myproject \\\n--os-username myuser token issue\n验证环境变量配置\nsource admin-openrc\nopenstack token issue\nGlance\n创建和配置数据库\nmysql -u root -p\nCREATE DATABASE glance;\nGRANT ALL PRIVILEGES ON glance.* TO &#039;glance&#039;@&#039;localhost&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\nGRANT ALL PRIVILEGES ON glance.* TO &#039;glance&#039;@&#039;%&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\nflush privileges;\n创建glance用户\nsource admin-openrc\nopenstack user create --domain default --password-prompt glance\n将admin加入service项目和glance用户\nopenstack role add --project service --user glance admin\n创建glance服务实体\nopenstack service create --name glance --description &quot;OpenStack Image&quot; image\n创建glance服务API端点,OpenStack使用三种API端点变种代表每种服务：admin、internal、public\nopenstack endpoint create --region RegionOne image public http://ctl01:9292\nopenstack endpoint create --region RegionOne image internal http://ctl01:9292\nopenstack endpoint create --region RegionOne image admin http://ctl01:9292\n安装glance软件包\nyum install openstack-glance\n编辑glance配置文件 /etc/glance/glance-api.conf\ncp -a /etc/glance/glance-api.conf{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/glance/glance-api.conf.bak &gt; /etc/glance/glance-api.conf\nopenstack-utils能够让openstack安装更加简单，直接在命令行修改配置文件\nyum install openstack-utils\n修改配置文件\n配置数据库访问\nopenstack-config --set /etc/glance/glance-api.conf database connection  mysql+pymysql://glance:Abc-1234@ctl01/glance\n配置身份服务访问\nopenstack-config --set /etc/glance/glance-api.conf keystone_authtoken www_authenticate_uri   http://ctl01:5000\nopenstack-config --set /etc/glance/glance-api.conf keystone_authtoken auth_url  http://ctl01:5000\nopenstack-config --set /etc/glance/glance-api.conf keystone_authtoken memcached_servers  ctl01:11211\nopenstack-config --set /etc/glance/glance-api.conf keystone_authtoken auth_type  password\nopenstack-config --set /etc/glance/glance-api.conf keystone_authtoken project_domain_name  Default\nopenstack-config --set /etc/glance/glance-api.conf keystone_authtoken user_domain_name  Default\nopenstack-config --set /etc/glance/glance-api.conf keystone_authtoken project_name  service\nopenstack-config --set /etc/glance/glance-api.conf keystone_authtoken username  glance\nopenstack-config --set /etc/glance/glance-api.conf keystone_authtoken password  Abc-1234\nopenstack-config --set /etc/glance/glance-api.conf paste_deploy flavor  keystone\n配置本地文件系统和镜像文件位置\nopenstack-config --set /etc/glance/glance-api.conf glance_store stores  file,http\nopenstack-config --set /etc/glance/glance-api.conf glance_store default_store  file\nopenstack-config --set /etc/glance/glance-api.conf glance_store filesystem_store_datadir  /var/lib/glance/images/\n填充数据库\nsu -s /bin/sh -c &quot;glance-manage db_sync&quot; glance\n# 忽略此输出中的任何弃用消息\n开机启动\nsystemctl enable openstack-glance-api.service\nsystemctl restart openstack-glance-api.service\nsystemctl status openstack-glance-api.service\nglance 启动报错处理：注意配置文件中是否含有特殊编码字符，在文本编辑器中检查\nDec 18 10:09:28 ctl01 glance-api[7727]: ERROR: &#039;ascii&#039; codec can&#039;t decode byte 0xc2 in position 11: ordinal not in range(128)\n\n解决方式：更换编码方式\n问题原因，ascii编码方式不能编码其他的内容\n在 cd /usr/lib/python2.7/site-packages/目录下新建一个文件sitecustomize.py\n内容为\n# sitecustomize.py\n# this file can be anywhere in your Python path,\n# but it usually goes in ${pythondir}/lib/site-packages/\nimport sys\nsys.setdefaultencoding(&#039;utf-8&#039;)\n再填充数据库即可\n验证\n下载cirros镜像\nsource admin-openrc\nwget http://download.cirros-cloud.net/0.4.0/cirros-0.4.0-x86_64-disk.img\n# 速度较慢，可浏览器进行下载后上传到控制节点\n上传镜像\n# 不推荐使用官方文档glance image-create这样的写法，新版本的OpenStack已经不支持，统一使用以openstack开头的命令写法\n \nopenstack image create --file ~/cirros-0.4.0-x86_64-disk.img --disk-format qcow2 --container-format bare --public cirros\n查看镜像\nopenstack image list\n查看镜像本地文件\nll /var/lib/glance/images/\nPlacement\n\nThe placement service enables other projects to track their own resources. Those projects can register/delete their own resources to/from placement via the placement HTTP API.\n\n创建和配置数据库\nmysql -u root -p\nCREATE DATABASE placement;\n授予权限\nGRANT ALL PRIVILEGES ON placement.* TO &#039;placement&#039;@&#039;localhost&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\nGRANT ALL PRIVILEGES ON placement.* TO &#039;placement&#039;@&#039;%&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\n配置生效\nflush privileges;\n创建用户和添加到项目中，此处配置密码Abc-1234\nsource admin-openrc\nopenstack user create --domain default --password-prompt placement\nopenstack role add --project service --user placement admin\n创建服务实体\nopenstack service create --name placement --description &quot;Placement API&quot; placement\n创建placement API服务访问端点\nopenstack endpoint create --region RegionOne placement public http://ctl01:8778\nopenstack endpoint create --region RegionOne placement internal http://ctl01:8778\nopenstack endpoint create --region RegionOne placement admin http://ctl01:8778\n安装placement软件包\nyum install openstack-placement-api\n备份和修改配置\ncp /etc/placement/placement.conf /etc/placement/placement.conf.bak\ngrep -Ev &#039;^$|#&#039; /etc/placement/placement.conf.bak &gt; /etc/placement/placement.conf\nopenstack-config --set /etc/placement/placement.conf placement_database connection mysql+pymysql://placement:Abc-1234@ctl01/placement\nopenstack-config --set /etc/placement/placement.conf api auth_strategy keystone\nopenstack-config --set /etc/placement/placement.conf keystone_authtoken auth_url  http://ctl01:5000/v3\nopenstack-config --set /etc/placement/placement.conf keystone_authtoken memcached_servers ctl01:11211\nopenstack-config --set /etc/placement/placement.conf keystone_authtoken auth_type password\nopenstack-config --set /etc/placement/placement.conf keystone_authtoken project_domain_name Default\nopenstack-config --set /etc/placement/placement.conf keystone_authtoken user_domain_name Default\nopenstack-config --set /etc/placement/placement.conf keystone_authtoken project_name service\nopenstack-config --set /etc/placement/placement.conf keystone_authtoken username placement\nopenstack-config --set /etc/placement/placement.conf keystone_authtoken password Abc-1234\n填充placement数据库\n[root@ctl01 ~]# su -s /bin/sh -c &quot;placement-manage db sync&quot; placement\n/usr/lib/python2.7/site-packages/pymysql/cursors.py:170: Warning: (1280, u&quot;Name &#039;alembic_version_pkc&#039; ignored for PRIMARY key.&quot;)\n  result = self._query(query)\n报错处理，再执行一次\n[root@ctl01 ~]# su -s /bin/sh -c &quot;placement-manage db sync&quot; placement\n\n修改placement的apache配置文件，官方文档没有提到，如果不修改，计算服务检查时将会报错\n#启用placement API访问，在16行下增加下列配置段\nvi /etc/httpd/conf.d/00-placement-api.conf\n...\n#SSLCertificateKeyFile\n#SSLCertificateKeyFile ...\n&lt;Directory /usr/bin&gt;\n&lt;IfVersion &gt;= 2.4&gt;\nRequire all granted\n&lt;/IfVersion&gt;\n&lt;IfVersion &lt; 2.4&gt;\nOrder allow,deny\nAllow from all\n&lt;/IfVersion&gt;\n&lt;/Directory&gt;\n...\n重启apache服务验证\nsystemctl restart httpd.service\nsystemctl status httpd.service\nnetstat -lntup|grep 8778\ncurl测试返回json\n[root@ctl01 ~]# curl http://ctl01:8778\n{&quot;versions&quot;: [{&quot;status&quot;: &quot;CURRENT&quot;, &quot;min_version&quot;: &quot;1.0&quot;, &quot;max_version&quot;: &quot;1.36&quot;, &quot;id&quot;: &quot;v1.0&quot;, &quot;links&quot;: [{&quot;href&quot;: &quot;&quot;, &quot;rel&quot;: &quot;self&quot;}]}]}\n验证检查健康状态\nplacement-status upgrade check\nNova\n控制节点\n创建nova_api，nova和nova_cell0数据库并授权\nCREATE DATABASE nova_api;\nCREATE DATABASE nova;\nCREATE DATABASE nova_cell0;\nGRANT ALL PRIVILEGES ON nova_api.* TO &#039;nova&#039;@&#039;localhost&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\nGRANT ALL PRIVILEGES ON nova_api.* TO &#039;nova&#039;@&#039;%&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\nGRANT ALL PRIVILEGES ON nova.* TO &#039;nova&#039;@&#039;localhost&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\nGRANT ALL PRIVILEGES ON nova.* TO &#039;nova&#039;@&#039;%&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\nGRANT ALL PRIVILEGES ON nova_cell0.* TO &#039;nova&#039;@&#039;localhost&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\nGRANT ALL PRIVILEGES ON nova_cell0.* TO &#039;nova&#039;@&#039;%&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\nflush privileges;\n创建和配置nova账户\nsource admin-openrc\nopenstack user create --domain default --password Abc-1234 nova\n向nova用户添加admin角色\nopenstack role add --project service --user nova admin\n创建nova服务实体\nopenstack service create --name nova --description &quot;OpenStack Compute&quot; compute\n创建Compute API服务端点\nopenstack endpoint create --region RegionOne compute public http://ctl01:8774/v2.1\nopenstack endpoint create --region RegionOne compute internal http://ctl01:8774/v2.1\nopenstack endpoint create --region RegionOne compute admin http://ctl01:8774/v2.1\n安装Nova相关软件包\nyum install openstack-nova-api openstack-nova-conductor openstack-nova-novncproxy openstack-nova-scheduler\n备份和编辑nova配置文件/etc/nova/nova.conf\ncp -a /etc/nova/nova.conf{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/nova/nova.conf.bak &gt; /etc/nova/nova.conf\n \n# In the `[vnc]` section, configure the VNC proxy to use the management interface IP address of the controller node\nmy_ip=10.191.101.128\nopenstack-config --set /etc/nova/nova.conf DEFAULT enabled_apis  osapi_compute,metadata\nopenstack-config --set /etc/nova/nova.conf DEFAULT my_ip &quot;$my_ip&quot;\nopenstack-config --set /etc/nova/nova.conf DEFAULT use_neutron  true\nopenstack-config --set /etc/nova/nova.conf DEFAULT firewall_driver  nova.virt.firewall.NoopFirewallDriver\nopenstack-config --set /etc/nova/nova.conf DEFAULT transport_url  rabbit://openstack:Abc-1234@ctl01\nopenstack-config --set /etc/nova/nova.conf api_database connection  mysql+pymysql://nova:Abc-1234@ctl01/nova_api\nopenstack-config --set /etc/nova/nova.conf database connection  mysql+pymysql://nova:Abc-1234@ctl01/nova\nopenstack-config --set /etc/nova/nova.conf placement_database connection  mysql+pymysql://placement:Abc-1234@ctl01/placement\nopenstack-config --set /etc/nova/nova.conf api auth_strategy  keystone\nopenstack-config --set /etc/nova/nova.conf keystone_authtoken auth_url  http://ctl01:5000/v3\nopenstack-config --set /etc/nova/nova.conf keystone_authtoken memcached_servers  ctl01:11211\nopenstack-config --set /etc/nova/nova.conf keystone_authtoken auth_type  password\nopenstack-config --set /etc/nova/nova.conf keystone_authtoken project_domain_name  Default\nopenstack-config --set /etc/nova/nova.conf keystone_authtoken user_domain_name  Default\nopenstack-config --set /etc/nova/nova.conf keystone_authtoken project_name  service\nopenstack-config --set /etc/nova/nova.conf keystone_authtoken username  nova\nopenstack-config --set /etc/nova/nova.conf keystone_authtoken password  Abc-1234\nopenstack-config --set /etc/nova/nova.conf vnc enabled  true\nopenstack-config --set /etc/nova/nova.conf vnc server_listen  &#039;$my_ip&#039;\nopenstack-config --set /etc/nova/nova.conf vnc server_proxyclient_address  &#039;$my_ip&#039;\nopenstack-config --set /etc/nova/nova.conf glance api_servers  http://ctl01:9292\nopenstack-config --set /etc/nova/nova.conf oslo_concurrency lock_path  /var/lib/nova/tmp\nopenstack-config --set /etc/nova/nova.conf placement region_name  RegionOne\nopenstack-config --set /etc/nova/nova.conf placement project_domain_name  Default\nopenstack-config --set /etc/nova/nova.conf placement project_name  service\nopenstack-config --set /etc/nova/nova.conf placement auth_type  password\nopenstack-config --set /etc/nova/nova.conf placement user_domain_name  Default\nopenstack-config --set /etc/nova/nova.conf placement auth_url  http://ctl01:5000/v3\nopenstack-config --set /etc/nova/nova.conf placement username  placement\nopenstack-config --set /etc/nova/nova.conf placement password  Abc-1234\n填充nova-api数据库\nsu -s /bin/sh -c &quot;nova-manage api_db sync&quot; nova\nsu -s /bin/sh -c &quot;nova-manage cell_v2 map_cell0&quot; nova\nsu -s /bin/sh -c &quot;nova-manage cell_v2 create_cell --name=cell1 --verbose&quot; nova\nsu -s /bin/sh -c &quot;nova-manage db sync&quot; nova\n/usr/lib/python2.7/site-packages/pymysql/cursors.py:170: Warning: (1831, u&#039;Duplicate index `block_device_mapping_instance_uuid_virtual_name_device_name_idx`. This is deprecated and will be disallowed in a future release&#039;)\n  result = self._query(query)\n/usr/lib/python2.7/site-packages/pymysql/cursors.py:170: Warning: (1831, u&#039;Duplicate index `uniq_instances0uuid`. This is deprecated and will be disallowed in a future release&#039;)\n  result = self._query(query)\n报错处理，再执行一次\nsu -s /bin/sh -c &quot;nova-manage db sync&quot; nova\n验证nova cell0和cell1是否正确注册\nsu -s /bin/sh -c &quot;nova-manage cell_v2 list_cells&quot; nova\n配置开机启动和启动服务\nsystemctl enable \\\nopenstack-nova-api.service \\\nopenstack-nova-scheduler.service \\\nopenstack-nova-conductor.service \\\nopenstack-nova-novncproxy.service\n \nsystemctl restart \\\nopenstack-nova-api.service \\\nopenstack-nova-scheduler.service \\\nopenstack-nova-conductor.service \\\nopenstack-nova-novncproxy.service\n检查运行状态\nsystemctl status \\\nopenstack-nova-api.service \\\nopenstack-nova-scheduler.service \\\nopenstack-nova-conductor.service \\\nopenstack-nova-novncproxy.service\n检查nova服务状态\nnetstat -tnlup|egrep &#039;8774|8775&#039;\ncurl http://ctl01:8774\n计算节点\n安装软件包\nyum install openstack-nova-compute\nyum install openstack-utils\n备份和编辑nova配置文件\ncp /etc/nova/nova.conf{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/nova/nova.conf.bak &gt; /etc/nova/nova.conf\n \nmy_ip=10.191.101.129\nopenstack-config --set  /etc/nova/nova.conf DEFAULT enabled_apis  osapi_compute,metadata\nopenstack-config --set  /etc/nova/nova.conf DEFAULT transport_url  rabbit://openstack:Abc-1234@ctl01\nopenstack-config --set  /etc/nova/nova.conf DEFAULT my_ip &quot;$my_ip&quot;\nopenstack-config --set  /etc/nova/nova.conf DEFAULT use_neutron  true\nopenstack-config --set  /etc/nova/nova.conf DEFAULT firewall_driver  nova.virt.firewall.NoopFirewallDriver\nopenstack-config --set  /etc/nova/nova.conf api auth_strategy  keystone\nopenstack-config --set  /etc/nova/nova.conf keystone_authtoken auth_url  http://ctl01:5000/v3\nopenstack-config --set  /etc/nova/nova.conf keystone_authtoken memcached_servers  ctl01:11211\nopenstack-config --set  /etc/nova/nova.conf keystone_authtoken auth_type  password\nopenstack-config --set  /etc/nova/nova.conf keystone_authtoken project_domain_name  Default\nopenstack-config --set  /etc/nova/nova.conf keystone_authtoken user_domain_name  Default\nopenstack-config --set  /etc/nova/nova.conf keystone_authtoken project_name  service\nopenstack-config --set  /etc/nova/nova.conf keystone_authtoken username  nova\nopenstack-config --set  /etc/nova/nova.conf keystone_authtoken password  Abc-1234\nopenstack-config --set  /etc/nova/nova.conf vnc enabled  true\nopenstack-config --set  /etc/nova/nova.conf vnc server_listen  0.0.0.0\nopenstack-config --set  /etc/nova/nova.conf vnc server_proxyclient_address &#039;$my_ip&#039;\nopenstack-config --set  /etc/nova/nova.conf vnc novncproxy_base_url http://ctl01:6080/vnc_auto.html\nopenstack-config --set  /etc/nova/nova.conf glance api_servers  http://ctl01:9292\nopenstack-config --set  /etc/nova/nova.conf oslo_concurrency lock_path  /var/lib/nova/tmp\nopenstack-config --set  /etc/nova/nova.conf placement region_name  RegionOne\nopenstack-config --set  /etc/nova/nova.conf placement project_domain_name  Default\nopenstack-config --set  /etc/nova/nova.conf placement project_name  service\nopenstack-config --set  /etc/nova/nova.conf placement auth_type  password\nopenstack-config --set  /etc/nova/nova.conf placement user_domain_name  Default\nopenstack-config --set  /etc/nova/nova.conf placement auth_url  http://ctl01:5000/v3\nopenstack-config --set  /etc/nova/nova.conf placement username  placement\nopenstack-config --set  /etc/nova/nova.conf placement password  Abc-1234\n确定计算节点是否支持虚拟机硬件加速\negrep -c &#039;(vmx|svm)&#039; /proc/cpuinfo\n# 如果此命令返回值不是0，则计算节点支持硬件加速，不需要加入下面的配置。\n# 如果此命令返回值是0，则计算节点不支持硬件加速，并且必须配置libvirt为使用QEMU而不是KVM，需要编辑/etc/nova/nova.conf 配置文件中的[libvirt]部分：\nopenstack-config --set  /etc/nova/nova.conf libvirt virt_type  qemu\n启动计算节点的nova服务及其相关服务，并设置开机自启\n# 如果nova-compute服务无法启动，请检查 /var/log/nova/nova-compute.log，该错误消息可能表明控制器节点上的防火墙阻止访问端口5672，将防火墙配置为打开控制器节点上的端口5672并重新启动计算节点上的服务\nsystemctl restart libvirtd.service openstack-nova-compute.service\nsystemctl enable libvirtd.service openstack-nova-compute.service\n在控制节点（ctl01）上验证计算节点\nopenstack compute service list --service nova-compute\n控制节点上发现计算主机\n# 添加每台新的计算节点时，必须在控制器节点上运行以下命令以注册这些新的计算节点\nsu -s /bin/sh -c &quot;nova-manage cell_v2 discover_hosts --verbose&quot; nova\n# 也可以设置适当的发现时间间隔来添加新的计算节点\nopenstack-config --set  /etc/nova/nova.conf scheduler discover_hosts_in_cells_interval 600\nsystemctl restart openstack-nova-api.service\n在控制节点上验证nova服务\n列出服务组件以验证每个进程的成功启动和注册情况\nopenstack compute service list\n列出身份服务中的API端点以验证与身份服务的连接\nopenstack catalog list\n列出镜像服务中的镜像以验证与镜像服务的连接性\nopenstack image list\n检查Cells和placement API是否正常运行\nnova-status upgrade check\nWindows计算节点\nNeutron\n控制节点\n创建neutron数据库\nmysql -uroot -pAbc-1234\nCREATE DATABASE neutron;\nGRANT ALL PRIVILEGES ON neutron.* TO &#039;neutron&#039;@&#039;localhost&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\nGRANT ALL PRIVILEGES ON neutron.* TO &#039;neutron&#039;@&#039;%&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\nflush privileges;\n创建neutron用户\nsource admin-openrc\nopenstack user create --domain default --password Abc-1234 neutron\n向neutron用户添加admin角色\nopenstack role add --project service --user neutron admin\n创建neutron服务实体\nopenstack service create --name neutron --description &quot;OpenStack Networking&quot; network\n创建neutron服务端点\nopenstack endpoint create --region RegionOne network public http://ctl01:9696\nopenstack endpoint create --region RegionOne network internal http://ctl01:9696\nopenstack endpoint create --region RegionOne network admin http://ctl01:9696\nProvider Networks\n安装neutron软件包\nyum install openstack-neutron openstack-neutron-ml2 openstack-neutron-linuxbridge ebtables\n# openstack-neutron：neutron-server的包\n# openstack-neutron-ml2：ML2 plugin的包\n# openstack-neutron-linuxbridge：linux bridge network provider相关的包\n# ebtables：防火墙相关的包\n编辑neutron服务配置文件/etc/neutron/neutron.conf\n# 配置二层网络\ncp -a /etc/neutron/neutron.conf{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/neutron/neutron.conf.bak &gt; /etc/neutron/neutron.conf\n \nopenstack-config --set  /etc/neutron/neutron.conf database connection  mysql+pymysql://neutron:Abc-1234@ctl01/neutron\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT core_plugin ml2\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT service_plugins router\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT allow_overlapping_ips true\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT transport_url  rabbit://openstack:Abc-1234@ctl01\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT auth_strategy  keystone\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT notify_nova_on_port_status_changes  true\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT notify_nova_on_port_data_changes  true\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken www_authenticate_uri  http://ctl01:5000\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken auth_url  http://ctl01:5000\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken memcached_servers  ctl01:11211\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken auth_type  password\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken project_domain_name  default\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken user_domain_name  default\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken project_name  service\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken username  neutron\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken password  Abc-1234\nopenstack-config --set  /etc/neutron/neutron.conf oslo_concurrency lock_path  /var/lib/neutron/tmp\nopenstack-config --set  /etc/neutron/neutron.conf nova  auth_url http://ctl01:5000\nopenstack-config --set  /etc/neutron/neutron.conf nova  auth_type password\nopenstack-config --set  /etc/neutron/neutron.conf nova  project_domain_name default\nopenstack-config --set  /etc/neutron/neutron.conf nova  user_domain_name default\nopenstack-config --set  /etc/neutron/neutron.conf nova  region_name RegionOne\nopenstack-config --set  /etc/neutron/neutron.conf nova  project_name service\nopenstack-config --set  /etc/neutron/neutron.conf nova  username nova\nopenstack-config --set  /etc/neutron/neutron.conf nova  password Abc-1234\nML2 plugin的配置文件ml2_conf.ini\ncp -a /etc/neutron/plugins/ml2/ml2_conf.ini{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/neutron/plugins/ml2/ml2_conf.ini.bak &gt; /etc/neutron/plugins/ml2/ml2_conf.ini\n \nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 type_drivers  flat,vlan,vxlan\nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 tenant_network_types vxlan\nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 mechanism_drivers  linuxbridge,l2population\nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 extension_drivers  port_security\nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2_type_flat flat_networks  provider\nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini linux_bridge physical_interface_mappings provider:ens33\nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2_type_vxlan vni_ranges 1:1000\nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini securitygroup enable_ipset  true\n配置linux网桥代理\nLinux网桥代理为实例构建第2层（桥接和交换）虚拟网络基础结构并处理安全组\n修改配置文件/etc/neutron/plugins/ml2/linuxbridge_agent.ini\n# 官方配置文档中，\n# PROVIDER_INTERFACE_NAME指的是eth0网卡，就是连接外部网络的那块网卡\n# OVERLAY_INTERFACE_IP_ADDRESS指的是控制节点访问外网的IP地址\n \ncp -a /etc/neutron/plugins/ml2/linuxbridge_agent.ini{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/neutron/plugins/ml2/linuxbridge_agent.ini.bak &gt; /etc/neutron/plugins/ml2/linuxbridge_agent.ini\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini linux_bridge physical_interface_mappings  provider:ens33\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan enable_vxlan  true\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan local_ip 10.191.101.128\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan l2_population true\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini securitygroup enable_security_group  true\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini securitygroup firewall_driver  neutron.agent.linux.iptables_firewall.IptablesFirewallDriver\n \n# 修改linux内核参数设置为1\necho &#039;net.bridge.bridge-nf-call-iptables=1&#039; &gt;&gt;/etc/sysctl.conf\necho &#039;net.bridge.bridge-nf-call-ip6tables=1&#039;  &gt;&gt;/etc/sysctl.conf\n \n# 启用网络桥接器支持，加载 br_netfilter 内核模块\nmodprobe br_netfilter\nsysctl -p\n \n配置第3层 l3代理为自助式虚拟网络提供路由和NAT服务\n# 配置三层网络\ncp -a /etc/neutron/l3_agent.ini{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/neutron/l3_agent.ini.bak &gt; /etc/neutron/l3_agent.ini\n \nopenstack-config --set /etc/neutron/l3_agent.ini DEFAULT interface_driver linuxbridge\n配置DHCP代理，DHCP代理为虚拟网络提供DHCP服务\n# 修改配置文件/etc/neutron/dhcp_agent.ini\ncp -a /etc/neutron/dhcp_agent.ini{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/neutron/dhcp_agent.ini.bak &gt; /etc/neutron/dhcp_agent.ini\n \nopenstack-config --set  /etc/neutron/dhcp_agent.ini DEFAULT interface_driver linuxbridge\nopenstack-config --set  /etc/neutron/dhcp_agent.ini DEFAULT dhcp_driver neutron.agent.linux.dhcp.Dnsmasq\nopenstack-config --set  /etc/neutron/dhcp_agent.ini DEFAULT enable_isolated_metadata true\n配置元数据代理\n# 元数据代理提供配置信息，例如实例的凭据\n# 修改配置文件/etc/neutron/metadata_agent.ini ，并为元数据设置密码METADATA_SECRET\n \ncp -a /etc/neutron/metadata_agent.ini{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/neutron/metadata_agent.ini.bak &gt; /etc/neutron/metadata_agent.ini\n \nopenstack-config --set  /etc/neutron/metadata_agent.ini DEFAULT nova_metadata_host  controller\nopenstack-config --set  /etc/neutron/metadata_agent.ini DEFAULT metadata_proxy_shared_secret  Abc-1234\n \n在控制节点上配置Nova服务与网络服务进行交互\n# 修改配置文件/etc/nova/nova.conf\nopenstack-config --set  /etc/nova/nova.conf neutron url  http://ctl01:9696\nopenstack-config --set  /etc/nova/nova.conf neutron auth_url  http://ctl01:5000\nopenstack-config --set  /etc/nova/nova.conf neutron auth_type  password\nopenstack-config --set  /etc/nova/nova.conf neutron project_domain_name  default\nopenstack-config --set  /etc/nova/nova.conf neutron user_domain_name  default\nopenstack-config --set  /etc/nova/nova.conf neutron region_name  RegionOne\nopenstack-config --set  /etc/nova/nova.conf neutron project_name  service\nopenstack-config --set  /etc/nova/nova.conf neutron username  neutron\nopenstack-config --set  /etc/nova/nova.conf neutron password  Abc-1234\nopenstack-config --set  /etc/nova/nova.conf neutron service_metadata_proxy  true\nopenstack-config --set  /etc/nova/nova.conf neutron metadata_proxy_shared_secret  Abc-1234\n创建ml2的软连接 文件指向ML2插件配置的软链接\nln -s /etc/neutron/plugins/ml2/ml2_conf.ini /etc/neutron/plugin.ini\n填充数据库\nsu -s /bin/sh -c &quot;neutron-db-manage --config-file /etc/neutron/neutron.conf \\\n--config-file /etc/neutron/plugins/ml2/ml2_conf.ini upgrade head&quot; neutron\n重新启动nova API计算服务\nsystemctl restart openstack-nova-api.service\n启动neutron服务和配置开机启动\nsystemctl enable neutron-server.service neutron-linuxbridge-agent.service neutron-dhcp-agent.service neutron-metadata-agent.service\nsystemctl restart neutron-server.service neutron-linuxbridge-agent.service neutron-dhcp-agent.service neutron-metadata-agent.service\n因配置了第3层l3网络服务 需要启动第三层服务\nsystemctl enable neutron-l3-agent.service\nsystemctl restart neutron-l3-agent.service\n计算节点安装neutron服务\n安装组件\nyum install openstack-neutron-linuxbridge ebtables ipset\n修改neutron主配置文件/etc/neutron/neutron.conf\ncp -a /etc/neutron/neutron.conf{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/neutron/neutron.conf.bak &gt; /etc/neutron/neutron.conf\n \nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT transport_url rabbit://openstack:Abc-1234@ctl01\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT auth_strategy keystone\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken www_authenticate_uri http://ctl01:5000\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken auth_url http://ctl01:5000\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken memcached_servers ctl01:11211\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken auth_type password\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken project_domain_name default\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken user_domain_name default\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken project_name service\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken username neutron\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken password Abc-1234\nopenstack-config --set  /etc/neutron/neutron.conf oslo_concurrency lock_path /var/lib/neutron/tmp\n配置Linux网桥代理\ncp -a /etc/neutron/plugins/ml2/linuxbridge_agent.ini{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/neutron/plugins/ml2/linuxbridge_agent.ini.bak &gt; /etc/neutron/plugins/ml2/linuxbridge_agent.ini\n \nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini linux_bridge physical_interface_mappings  provider:ens33\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan enable_vxlan  true\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan local_ip 10.191.101.129\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan l2_population true\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini securitygroup enable_security_group  true\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini securitygroup firewall_driver  neutron.agent.linux.iptables_firewall.IptablesFirewallDriver\n修改linux系统内核网桥参数为1\necho &#039;net.bridge.bridge-nf-call-iptables=1&#039; &gt;&gt;/etc/sysctl.conf\necho &#039;net.bridge.bridge-nf-call-ip6tables=1&#039;  &gt;&gt;/etc/sysctl.conf\nmodprobe br_netfilter\nsysctl -p\n配置计算节点上Nova服务使用网络服务\n# 修改nova配置文件/etc/nova/nova.conf，添加neutron模块配置\nopenstack-config --set  /etc/nova/nova.conf neutron auth_url http://ctl01:5000\nopenstack-config --set  /etc/nova/nova.conf neutron auth_type password\nopenstack-config --set  /etc/nova/nova.conf neutron project_domain_name default\nopenstack-config --set  /etc/nova/nova.conf neutron user_domain_name default\nopenstack-config --set  /etc/nova/nova.conf neutron region_name RegionOne\nopenstack-config --set  /etc/nova/nova.conf neutron project_name service\nopenstack-config --set  /etc/nova/nova.conf neutron username neutron\nopenstack-config --set  /etc/nova/nova.conf neutron password Abc-1234\n重新启动计算节点上的Nova服务\nsystemctl restart openstack-nova-compute.service\n启动neutron网桥代理服务 设置开机自启动\nsystemctl enable neutron-linuxbridge-agent.service\nsystemctl restart neutron-linuxbridge-agent.service\n回到控制节点验证Neutron网络服务\n# 列出已加载的扩展，以验证该neutron-server过程是否成功启动\nsource admin-openrc\nopenstack extension list --network\n \n# 列出代理商以验证成功\nopenstack network agent list\n安装neutron网络服务节点\n网络配置按照官网文档的租户自助网络\n配置系统参数\necho &#039;net.ipv4.ip_forward = 1&#039; &gt;&gt;/etc/sysctl.conf\nsysctl -p\n安装客户端\nyum install python-openstackclient\n安装组件\nyum install openstack-neutron openstack-neutron-ml2 openstack-neutron-linuxbridge ebtables openstack-utils\n编辑neutron服务配置文件/etc/neutron/neutron.conf\n# 配置二层网络\ncp -a /etc/neutron/neutron.conf{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/neutron/neutron.conf.bak &gt; /etc/neutron/neutron.conf\n \nopenstack-config --set  /etc/neutron/neutron.conf database connection  mysql+pymysql://neutron:Abc-1234@ctl01/neutron\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT core_plugin ml2\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT service_plugins router\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT allow_overlapping_ips true\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT transport_url  rabbit://openstack:Abc-1234@ctl01\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT auth_strategy  keystone\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT notify_nova_on_port_status_changes  true\nopenstack-config --set  /etc/neutron/neutron.conf DEFAULT notify_nova_on_port_data_changes  true\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken www_authenticate_uri  http://ctl01:5000\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken auth_url  http://ctl01:5000\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken memcached_servers  ctl01:11211\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken auth_type  password\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken project_domain_name  default\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken user_domain_name  default\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken project_name  service\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken username  neutron\nopenstack-config --set  /etc/neutron/neutron.conf keystone_authtoken password  Abc-1234\nopenstack-config --set  /etc/neutron/neutron.conf oslo_concurrency lock_path  /var/lib/neutron/tmp\nopenstack-config --set  /etc/neutron/neutron.conf nova  auth_url http://ctl01:5000\nopenstack-config --set  /etc/neutron/neutron.conf nova  auth_type password\nopenstack-config --set  /etc/neutron/neutron.conf nova  project_domain_name default\nopenstack-config --set  /etc/neutron/neutron.conf nova  user_domain_name default\nopenstack-config --set  /etc/neutron/neutron.conf nova  region_name RegionOne\nopenstack-config --set  /etc/neutron/neutron.conf nova  project_name service\nopenstack-config --set  /etc/neutron/neutron.conf nova  username nova\nopenstack-config --set  /etc/neutron/neutron.conf nova  password Abc-1234\nML2 plugin的配置文件ml2_conf.ini\ncp -a /etc/neutron/plugins/ml2/ml2_conf.ini{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/neutron/plugins/ml2/ml2_conf.ini.bak &gt; /etc/neutron/plugins/ml2/ml2_conf.ini\n \nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 type_drivers  flat,vlan,vxlan\nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 tenant_network_types vxlan\nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 mechanism_drivers  linuxbridge,l2population\nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 extension_drivers  port_security\nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2_type_flat flat_networks  provider\nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2_type_vxlan vni_ranges 1:1000\nopenstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini securitygroup enable_ipset  true\n配置Linux网桥代理\n# Linux网桥代理为实例构建第2层（桥接和交换）虚拟网络基础结构并处理安全组\n# 修改配置文件/etc/neutron/plugins/ml2/linuxbridge_agent.ini\n# 官网配置文档中：\n# PROVIDER_INTERFACE_NAME指的是eth0网卡，就是连接外部网络的那块网卡\n# OVERLAY_INTERFACE_IP_ADDRESS指的是控制节点访问外网的IP地址\n \ncp -a /etc/neutron/plugins/ml2/linuxbridge_agent.ini{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/neutron/plugins/ml2/linuxbridge_agent.ini.bak &gt; /etc/neutron/plugins/ml2/linuxbridge_agent.ini\n \nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini linux_bridge physical_interface_mappings  provider:ens33\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan enable_vxlan  true\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan local_ip 10.191.101.130\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan l2_population true\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini securitygroup enable_security_group  true\nopenstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini securitygroup firewall_driver  neutron.agent.linux.iptables_firewall.IptablesFirewallDriver\n \n# 修改linux内核参数设置为1\necho &#039;net.bridge.bridge-nf-call-iptables=1&#039; &gt;&gt;/etc/sysctl.conf\necho &#039;net.bridge.bridge-nf-call-ip6tables=1&#039;  &gt;&gt;/etc/sysctl.conf\n \n# 启用网络桥接器支持，加载 br_netfilter 内核模块\nmodprobe br_netfilter\nsysctl -p\n配置第3层 l3代理为自助式虚拟网络提供路由和NAT服务\n# 配置三层网络\ncp -a /etc/neutron/l3_agent.ini{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/neutron/l3_agent.ini.bak &gt; /etc/neutron/l3_agent.ini\n \nopenstack-config --set /etc/neutron/l3_agent.ini DEFAULT interface_driver linuxbridge\n配置DHCP代理，DHCP代理为虚拟网络提供DHCP服务\n# 修改配置文件/etc/neutron/dhcp_agent.ini\ncp -a /etc/neutron/dhcp_agent.ini{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/neutron/dhcp_agent.ini.bak &gt; /etc/neutron/dhcp_agent.ini\n \nopenstack-config --set  /etc/neutron/dhcp_agent.ini DEFAULT interface_driver linuxbridge\nopenstack-config --set  /etc/neutron/dhcp_agent.ini DEFAULT dhcp_driver neutron.agent.linux.dhcp.Dnsmasq\nopenstack-config --set  /etc/neutron/dhcp_agent.ini DEFAULT enable_isolated_metadata true\n配置元数据代理\n# 元数据代理提供配置信息，例如实例的凭据\n# 修改配置文件/etc/neutron/metadata_agent.ini ，并为元数据设置密码METADATA_SECRET\n \ncp -a /etc/neutron/metadata_agent.ini{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/neutron/metadata_agent.ini.bak &gt; /etc/neutron/metadata_agent.ini\n \nopenstack-config --set  /etc/neutron/metadata_agent.ini DEFAULT nova_metadata_host  controller\nopenstack-config --set  /etc/neutron/metadata_agent.ini DEFAULT metadata_proxy_shared_secret  Abc-1234\n创建ml2的软连接 文件指向ML2插件配置的软链接\nln -s /etc/neutron/plugins/ml2/ml2_conf.ini /etc/neutron/plugin.ini\n填充数据库\nsu -s /bin/sh -c &quot;neutron-db-manage --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/plugins/ml2/ml2_conf.ini upgrade head&quot; neutron\n在ctl01控制节点上配置nova服务与网络节点服务进行交互\n如果是单独安装网络节点则添加以下操作，如果已经在配置计算节点的网络服务时，在控制节点的配置文件/etc/nova/nova.conf添加了neutron模块 ,则不用再次添加\nopenstack-config --set  /etc/nova/nova.conf neutron url  http://ctl01:9696  #此条官方文档未添加\nopenstack-config --set  /etc/nova/nova.conf neutron auth_url  http://ctl01:5000\nopenstack-config --set  /etc/nova/nova.conf neutron auth_type  password\nopenstack-config --set  /etc/nova/nova.conf neutron project_domain_name  default\nopenstack-config --set  /etc/nova/nova.conf neutron user_domain_name  default\nopenstack-config --set  /etc/nova/nova.conf neutron region_name  RegionOne\nopenstack-config --set  /etc/nova/nova.conf neutron project_name  service\nopenstack-config --set  /etc/nova/nova.conf neutron username  neutron\nopenstack-config --set  /etc/nova/nova.conf neutron password  Abc-1234\nopenstack-config --set  /etc/nova/nova.conf neutron service_metadata_proxy  true\nopenstack-config --set  /etc/nova/nova.conf neutron metadata_proxy_shared_secret  Abc-1234\n# 在ctl01控制节点上重新启动nova API计算服务\nsystemctl restart openstack-nova-api.service\n回到网络节点启动neutron服务和配置开机启动\nsystemctl enable neutron-server.service neutron-linuxbridge-agent.service neutron-dhcp-agent.service neutron-metadata-agent.service\nsystemctl restart neutron-server.service neutron-linuxbridge-agent.service neutron-dhcp-agent.service neutron-metadata-agent.service\n因配置了第3层l3网络服务 需要启动第三层服务\nsystemctl enable neutron-l3-agent.service\nsystemctl restart neutron-l3-agent.service\n可以到控制节点再次验证Neutron网络服务\n# 列出已加载的扩展，以验证该neutron-server过程是否成功启动\nopenstack extension list --network\n# 列出代理商以验证成功\nopenstack network agent list\nHorizon\n在控制节点上安装horizon\n安装软件包\nyum install openstack-dashboard\n改配置文件/etc/openstack-dashboard/local_settings\ncp -a /etc/openstack-dashboard/local_settings{,.bak}\ngrep -Ev &#039;^$|#&#039; /etc/openstack-dashboard/local_settings.bak &gt;/etc/openstack-dashboard/local_settings\n在控制节点上配置仪表盘以使用 OpenStack 服务\nOPENSTACK_HOST = &quot;ctl01&quot;\n允许所有主机访问仪表板\nALLOWED_HOSTS = [&#039;*&#039;, ]\n配置 memcached 会话存储服务：\nSESSION_ENGINE = &#039;django.contrib.sessions.backends.cache&#039;\nCACHES = {\n    &#039;default&#039;: {\n         &#039;BACKEND&#039;: &#039;django.core.cache.backends.memcached.MemcachedCache&#039;,\n         &#039;LOCATION&#039;: &#039;ctl01:11211&#039;,\n    }\n}\n启用第3版认证API\nOPENSTACK_KEYSTONE_URL = &quot;http://%s:5000/v3&quot; % OPENSTACK_HOST\n启用对域的支持\nOPENSTACK_KEYSTONE_MULTIDOMAIN_SUPPORT = True\n配置API版本\nOPENSTACK_API_VERSIONS = {\n    &quot;identity&quot;: 3,\n    &quot;image&quot;: 2,\n    &quot;volume&quot;: 2,\n}\n通过仪表盘创建用户时的默认域配置为 default\nOPENSTACK_KEYSTONE_DEFAULT_DOMAIN = &quot;default&quot;\n通过仪表盘创建的用户默认角色配置为 user\nOPENSTACK_KEYSTONE_DEFAULT_ROLE = &quot;user&quot;\n如果您选择网络参数1，禁用支持3层网络服务\nOPENSTACK_NEUTRON_NETWORK = {\n    ...\n    &#039;enable_router&#039;: False,\n    &#039;enable_quotas&#039;: False,\n    &#039;enable_distributed_router&#039;: False,\n    &#039;enable_ha_router&#039;: False,\n    &#039;enable_lb&#039;: False,\n    &#039;enable_firewall&#039;: False,\n    &#039;enable_vpn&#039;: False,\n    &#039;enable_fip_topology_check&#039;: False,\n}\n可以选择性地配置时区\nTIME_ZONE = &quot;Asia/Shanghai&quot;\n全部配置说明\ncat /etc/openstack-dashboard/local_settings\n \n# 配置仪表盘在ctl01节点上使用OpenStack服务\nOPENSTACK_HOST = &quot;ctl01&quot;\n \n# 允许主机访问仪表板,接受所有主机,不安全不应在生产中使用\nALLOWED_HOSTS = [&#039;*&#039;]\n# ALLOWED_HOSTS = [&#039;one.example.com&#039;, &#039;two.example.com&#039;]\n \n# 配置memcached会话存储服务\nSESSION_ENGINE = &#039;django.contrib.sessions.backends.cache&#039;\nCACHES = {\n    &#039;default&#039;: {\n         &#039;BACKEND&#039;: &#039;django.core.cache.backends.memcached.MemcachedCache&#039;,\n         &#039;LOCATION&#039;: &#039;ctl01:11211&#039;,\n    }\n}\n \n# 启用身份API版本3\nOPENSTACK_KEYSTONE_URL = &quot;http://%s:5000/v3&quot; % OPENSTACK_HOST\n \n# 启用对域的支持\nOPENSTACK_KEYSTONE_MULTIDOMAIN_SUPPORT = True\n \n# 配置API版本\nOPENSTACK_API_VERSIONS = {\n    &quot;identity&quot;: 3,\n    &quot;image&quot;: 2,\n    &quot;volume&quot;: 3,\n}\n \n# 配置Default为通过仪表板创建的用户的默认域\nOPENSTACK_KEYSTONE_DEFAULT_DOMAIN = &quot;Default&quot;\n \n# 配置user为通过仪表板创建的用户的默认角色\nOPENSTACK_KEYSTONE_DEFAULT_ROLE = &quot;user&quot;\n \n# 如果选择网络选项1，请禁用对第3层网络服务的支持,如果选择网络选项2,则可以打开\nOPENSTACK_NEUTRON_NETWORK = {\n# 自动分配的网络\n    &#039;enable_auto_allocated_network&#039;: False,\n \n# Neutron分布式虚拟路由器（DVR）\n    &#039;enable_distributed_router&#039;: False,\n \n# FIP拓扑检查\n    &#039;enable_fip_topology_check&#039;: False,\n \n# 高可用路由器模式\n    &#039;enable_ha_router&#039;: False,\n \n# 下面三个已过时,不用过多了解,官方文档配置中是关闭的\n    &#039;enable_lb&#039;: False,\n    &#039;enable_firewall&#039;: False,\n    &#039;enable_vpn&#039;: False,\n \n# ipv6网络\n    &#039;enable_ipv6&#039;: True,\n \n# Neutron配额功能\n    &#039;enable_quotas&#039;: True,\n \n# rbac政策\n    &#039;enable_rbac_policy&#039;: True,\n \n# 路由器的菜单和浮动IP功能,如果Neutron部署有三层功能的支持可以打开\n    &#039;enable_router&#039;: True,\n \n# 默认的DNS名称服务器\n    &#039;default_dns_nameservers&#039;: [],\n \n# 网络支持的提供者类型,在创建网络时，该列表中的网络类型可供选择\n    &#039;supported_provider_types&#039;: [&#039;*&#039;],\n \n# 使用与提供网络ID范围,仅涉及到VLAN，GRE，和VXLAN网络类型\n    &#039;segmentation_id_range&#039;: {},\n \n# 使用与提供网络类型\n    &#039;extra_provider_types&#039;: {},\n \n# 支持的vnic类型,用于与端口绑定扩展\n    # &#039;supported_vnic_types&#039;: [&#039;*&#039;],\n \n# 物理网络\n    # &#039;physical_networks&#039;: [],\n}\n \n# 配置时区为亚洲上海\nTIME_ZONE = &quot;Asia/Shanghai&quot;\n重建apache的dashboard配置文件\ncd /usr/share/openstack-dashboard\npython manage.py make_web_conf --apache &gt; /etc/httpd/conf.d/openstack-dashboard.conf\n重新启动节点上的apache服务和memcache服务\nsystemctl restart httpd.service memcached.service\n访问dashboard\nhttp://10.191.101.128\n若不能正常访问，请操作以下步骤:建立策略文件（policy.json）的软链接，否则登录到dashboard将出现权限错误和显示混乱\nln -s /etc/openstack-dashboard /usr/share/openstack-dashboard/openstack_dashboard/conf\n# /etc/httpd/conf.d/openstack-dashboard.conf 如果未包含，则添加以下行\nWSGIApplicationGroup %{GLOBAL}\n身份认证dashboard无法打开\nvim /etc/httpd/conf.d/openstack-dashboard.conf\n \n# 将原有的配置注释掉\n#WSGIScriptAlias / /usr/share/openstack-dashboard/openstack_dashboard/wsgi.py\n#Alias /static /usr/share/openstack-dashboard/static\n \n# 添加以下配置\nWSGIScriptAlias /dashboard /usr/share/openstack-dashboard/openstack_dashboard/wsgi/django.wsgi\nAlias /dashboard/static /usr/share/openstack-dashboard/static\n在local_settings底下新增根目录指向\nvim /etc/openstack-dashboard/local_settings\nWEBROOT = &#039;/dashboard/&#039;\n编辑以下文件，找到WEBROOT = ’/’ 修改为WEBROOT = ‘/dashboard’\nvim /usr/share/openstack-dashboard/openstack_dashboard/defaults.py\nvim /usr/share/openstack-dashboard/openstack_dashboard/test/settings.py\nvim /usr/share/openstack-dashboard/static/dashboard/js/xxxx.js\n修改后重启服务即可\nsystemctl restart httpd.service memcached.service\nCinder\n控制节点配置\n在控制节点（ctl01：10.191.101.128）上配置\nmysql -u root -p\n创建数据库并授权\nCREATE DATABASE cinder;\nGRANT ALL PRIVILEGES ON cinder.* TO &#039;cinder&#039;@&#039;localhost&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\nGRANT ALL PRIVILEGES ON cinder.* TO &#039;cinder&#039;@&#039;%&#039; IDENTIFIED BY &#039;Abc-1234&#039;;\nflush privileges;\n创建cinder用户\nopenstack user create --domain default --password Abc-1234 cinder\n赋予Cinder权限为admin\nopenstack role add --project service --user cinder admin\n创建 cinder服务实体\nopenstack service create --name cinderv2 --description &quot;OpenStack Block Storage&quot; volumev2\nopenstack service create --name cinderv3 --description &quot;OpenStack Block Storage&quot; volumev3\n创建块设备存储服务的 API 入口点\nopenstack endpoint create --region RegionOne volumev2 public http://ctl01:8776/v2/%\\(project_id\\)s\nopenstack endpoint create --region RegionOne volumev2 internal http://ctl01:8776/v2/%\\(project_id\\)s\nopenstack endpoint create --region RegionOne volumev2 admin http://ctl01:8776/v2/%\\(project_id\\)s\nopenstack endpoint create --region RegionOne volumev3 public http://ctl01:8776/v3/%\\(project_id\\)s\nopenstack endpoint create --region RegionOne volumev3 internal http://ctl01:8776/v3/%\\(project_id\\)s\nopenstack endpoint create --region RegionOne volumev3 admin http://ctl01:8776/v3/%\\(project_id\\)s\n安装软件包\nyum install -y openstack-cinder\ncinder配置文件/etc/cinder/cinder.conf\nopenstack-config --set /etc/cinder/cinder.conf DEFAULT rpc_backend rabbit\nopenstack-config --set /etc/cinder/cinder.conf DEFAULT auth_strategy keystone\nopenstack-config --set /etc/cinder/cinder.conf DEFAULT my_ip 10.191.101.128\nopenstack-config --set /etc/cinder/cinder.conf DEFAULT transport_url  rabbit://openstack:Abc-1234@ctl01\nopenstack-config --set /etc/cinder/cinder.conf database connection mysql+pymysql://cinder:Abc-1234@ctl01/cinder\nopenstack-config --set /etc/cinder/cinder.conf oslo_messaging_rabbit rabbit_hosts ctl01:5672\nopenstack-config --set /etc/cinder/cinder.conf oslo_messaging_rabbit rabbit_userid openstack\nopenstack-config --set /etc/cinder/cinder.conf oslo_messaging_rabbit rabbit_password &#039;Abc-1234&#039;\nopenstack-config --set /etc/cinder/cinder.conf keystone_authtoken auth_url http://ctl01:5000\nopenstack-config --set /etc/cinder/cinder.conf keystone_authtoken www_authenticate_uri http://ctl01:5000\nopenstack-config --set /etc/cinder/cinder.conf keystone_authtoken memcached_servers ctl01:11211\nopenstack-config --set /etc/cinder/cinder.conf keystone_authtoken auth_type password\nopenstack-config --set /etc/cinder/cinder.conf keystone_authtoken project_domain_name default\nopenstack-config --set /etc/cinder/cinder.conf keystone_authtoken user_domain_name default\nopenstack-config --set /etc/cinder/cinder.conf keystone_authtoken project_name service\nopenstack-config --set /etc/cinder/cinder.conf keystone_authtoken username cinder\nopenstack-config --set /etc/cinder/cinder.conf keystone_authtoken password &#039;Abc-1234&#039;\nopenstack-config --set /etc/cinder/cinder.conf oslo_concurrency lock_path /var/lib/cinder/tmp\n初始化块设备服务的数据库：\nsu -s /bin/sh -c &quot;cinder-manage db sync&quot; cinder\n配置计算服务以使用块设备存储\nopenstack-config --set /etc/nova/nova.conf cinder os_region_name RegionOne\n重启nova计算和cinder块存储服务并设置开机自启动\nsystemctl restart openstack-nova-api.service\nsystemctl restart openstack-cinder-api.service openstack-cinder-scheduler.service\nsystemctl enable openstack-cinder-api.service openstack-cinder-scheduler.service\n存储节点配置\n在控制节点（cinder01：10.191.101.131）上配置\n安装LVM软件包\nyum install -y lvm2 device-mapper-persistent-data\n启动LVM元数据服务\nsystemctl enable lvm2-lvmetad.service\nsystemctl restart lvm2-lvmetad.service\n添加一块100G硬盘，重启节点后创建LVM物理卷/dev/sdb\npvcreate /dev/sdb\n创建LVM物理卷\nvgcreate cinder-volumes /dev/sdb\n编辑配置文件/etc/lvm/lvm.conf,在devices部分，添加一个过滤器，只接受/dev/sdb设备，拒绝其他所有设备\nvim /etc/lvm/lvm.conf\ndevices {\nfilter = [ &quot;a/sdb/&quot;, &quot;r/.*/&quot; ]\n安装train版yum源和cinder软件包\nyum install centos-release-openstack-train\nyum install openstack-cinder targetcli python-keystone openstack-utils\n编辑配置文件/etc/cinder/cinder.conf\ncp /etc/cinder/cinder.conf /etc/cinder/cinder.conf.bak\ngrep -Ev &#039;#|^$&#039; /etc/cinder/cinder.conf.bak&gt;/etc/cinder/cinder.conf\n \nmy_ip=10.191.101.131\nopenstack-config --set /etc/cinder/cinder.conf  database  connection mysql+pymysql://cinder:Abc-1234@ctl01/cinder\nopenstack-config --set /etc/cinder/cinder.conf  DEFAULT transport_url rabbit://openstack:Abc-1234@ctl01\nopenstack-config --set /etc/cinder/cinder.conf  DEFAULT auth_strategy keystone\nopenstack-config --set /etc/cinder/cinder.conf  DEFAULT my_ip &quot;$my_ip&quot;\nopenstack-config --set /etc/cinder/cinder.conf  DEFAULT enabled_backends lvm\nopenstack-config --set /etc/cinder/cinder.conf  DEFAULT glance_api_servers http://ctl01:9292\nopenstack-config --set /etc/cinder/cinder.conf  keystone_authtoken www_authenticate_uri http://ctl01:5000\nopenstack-config --set /etc/cinder/cinder.conf  keystone_authtoken auth_url http://ctl01:5000\nopenstack-config --set /etc/cinder/cinder.conf  keystone_authtoken memcached_servers ctl01:11211\nopenstack-config --set /etc/cinder/cinder.conf  keystone_authtoken auth_type password\nopenstack-config --set /etc/cinder/cinder.conf  keystone_authtoken project_domain_name default\nopenstack-config --set /etc/cinder/cinder.conf  keystone_authtoken user_domain_name default\nopenstack-config --set /etc/cinder/cinder.conf  keystone_authtoken project_name service\nopenstack-config --set /etc/cinder/cinder.conf  keystone_authtoken username cinder\nopenstack-config --set /etc/cinder/cinder.conf  keystone_authtoken password Abc-1234\nopenstack-config --set /etc/cinder/cinder.conf  lvm volume_driver cinder.volume.drivers.lvm.LVMVolumeDriver\nopenstack-config --set /etc/cinder/cinder.conf  lvm volume_group cinder-volumes\nopenstack-config --set /etc/cinder/cinder.conf  lvm target_protocol iscsi\nopenstack-config --set /etc/cinder/cinder.conf  lvm target_helper lioadm\nopenstack-config --set /etc/cinder/cinder.conf  oslo_concurrency lock_path /var/lib/cinder/tmp\n启动块存储卷服务并设置开机自启动\nsystemctl restart openstack-cinder-volume.service target.service\nsystemctl enable openstack-cinder-volume.service target.service\n在控制节点验证服务\nsource admin-openrc\nopenstack volume service list\n在dashboard查看\n\n创建卷测试\n\n\nOpenstack使用\n从cirros镜像创建卷测试创建虚拟机\n\n创建实例类型\n\n建立公共提供商网络\n创建网络\n在admin管理员下创建\nopenstack network create --share --external --provider-physical-network provider --provider-network-type flat provider\n参数理解：\n--share 允许所有项目使用虚拟网络\n--external 将虚拟网络定义为外部,如果想创建一个内部网络，则可以使用--internal。默认值为internal\n--provider-physical-network provider\n# 指明物理网络的提供者，provider 与下面neutron的配置文件对应，其中provider是标签，可以更改为其他，但是2个地方必须要统一\n \n \n# 配置文件/etc/neutron/plugins/ml2/ml2_conf.ini中的参数\n[ml2_type_flat]\nflat_networks = provider\n[linux_bridge]\nphysical_interface_mappings = provider:ens33\n \n--provider-network-type flat 指明这里创建的网络是flat类型，即实例连接到此网络时和物理网络是在同一个网段，无vlan等功能。\n \n最后输入的provider 指定网络的名称\n \n创建子网\n在网络上创建一个子网 10.191.101.0/24 ; 子网对应真实的物理网络\nopenstack subnet create --network provider \\\n  --allocation-pool start=10.191.101.10,end=10.191.101.20 \\\n  --dns-nameserver 10.191.101.2 --gateway 10.191.101.2 \\\n  --subnet-range 10.191.101.0/24 provider\n \n# 参数解释:\n--network provider 指定父网络\n--allocation-pool start=10.191.101.10,end=10.191.101.20 指定子网的起始地址和终止地址\n--dns-nameserver 10.191.101.2 指定DNS服务器地址\n--gateway 10.191.101.2 指定网关地址\n--subnet-range 10.191.101.0/24 指定子网的网段\n \n最后的provider 指定子网的名称\n创建实例\n\n测试网络\n\n建立普通租户的私有自助服务网络\n创建网络\n自助服务网络，也叫租户网络或项目网络，它是由openstack租户创建的，完全虚拟的，是租户私有的，只在本网络内部连通，不能在租户之间共享\n在普通租户下创建网络，当前使用账号myuser，重置密码为Abc-1234\n\n非特权用户通常无法为该命令提供其他参数，该服务使用以下配置文件中的信息自动选择参数\ncat /etc/neutron/plugins/ml2/ml2_conf.ini\n \n[ml2]\ntype_drivers = flat,vlan,vxlan\ntenant_network_types = vxlan\n[ml2_type_vxlan]\nvni_ranges = 1:1000\n创建子网\n创建一个子网 172.18.1.0/24\n\n创建路由\n使用命令创建，配置myuser环境变量\ncat myuser-openrc\n \nexport OS_USERNAME=myuser\nexport OS_PASSWORD=Abc-1234\nexport OS_PROJECT_NAME=myproject\nexport OS_USER_DOMAIN_NAME=Default\nexport OS_PROJECT_DOMAIN_NAME=Default\nexport OS_AUTH_URL=http://ctl01:5000/v3\nexport OS_IDENTITY_API_VERSION=3\n查看已创建的网络\nopenstack network list\n查看已创建的子网\nopenstack subnet list\n创建路由器，用myuser普通租户创建\nsource ~/myuser-openrc\nopenstack router create router01\n查看创建的路由\nopenstack router list\n将创建的租户自助服务网络子网添加为路由器上的接口\nopenstack router add subnet router01 selfservice\n在路由器的公共提供商网络上设置网关\nopenstack router set router01 --external-gateway provider\nIp nets\n[root@ctl01 ~]# ip netns\n \nqrouter-7962017d-fd01-4863-aae0-329fd704bc78 (id: 1)\nqdhcp-28e70282-9aff-4048-8e17-9a2879f9eab2 (id: 0)\n# 使用ip netns命令找到这个虚拟路由器之后，用这个虚拟路由器ping真实物理网络中的网关，ping通即证明OpenStack内部虚拟网络与真实物理网络衔接成功\n \n[root@ctl01 ~]# ip netns\nqrouter-7962017d-fd01-4863-aae0-329fd704bc78 (id: 1)\nqdhcp-28e70282-9aff-4048-8e17-9a2879f9eab2 (id: 0)\n \n[root@ctl01 ~]# ip netns exec qrouter-7962017d-fd01-4863-aae0-329fd704bc78 ping 10.191.101.2\nPING 10.191.101.2 (10.191.101.2) 56(84) bytes of data.\n64 bytes from 10.191.101.2: icmp_seq=1 ttl=128 time=0.663 ms\n64 bytes from 10.191.101.2: icmp_seq=2 ttl=128 time=0.235 ms\n验证查看创建网络和子网中的IP地址范围，回到admin用户下\n列出路由器上的端口，以确定提供商网络上的网关IP地址\nopenstack port list --router router01\n+--------------------------------------+------+-------------------+------------------------------------------------------------------------------+--------+\n| ID                                   | Name | MAC Address       | Fixed IP Addresses                                                           | Status |\n+--------------------------------------+------+-------------------+------------------------------------------------------------------------------+--------+\n| 2cfa2e4b-3b57-4aa3-af77-59eca94242eb |      | fa:16:3e:56:7f:9a | ip_address=&#039;172.18.1.1&#039;, subnet_id=&#039;1213f505-8e0d-4b5e-b7b9-f659aaf92486&#039;    | ACTIVE |\n| be99fadb-47fd-4247-b504-baf00d810f8d |      | fa:16:3e:8e:1a:4d | ip_address=&#039;10.191.101.13&#039;, subnet_id=&#039;4f7508fd-b250-44b8-be9c-f2d840abd852&#039; | ACTIVE |\n+--------------------------------------+------+-------------------+------------------------------------------------------------------------------+--------+\nCeph安装\n节点规划：单节点\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nceph01（可选）ceph单节点10.191.101.140/24192.168.80.140/241C2G\n系统版本\ncat /etc/redhat-release\nCentOS Linux release 7.6.1810 (Core)\n自动补全\nyum install -y bash-completion\n主机名\nhostnamectl set-hostname ceph01\nYum配置\nrm /etc/yum.repos.d/* -rf\ncurl http://mirrors.aliyun.com/repo/Centos-7.repo &gt; /etc/yum.repos.d/Centos-7.repo\ncurl http://mirrors.aliyun.com/repo/epel-7.repo &gt; /etc/yum.repos.d/epel.repo\nCeph yum源\nvi  /etc/yum.repos.d/ceph.repo\n[Ceph]\nname=Ceph packages for $basearch\nbaseurl=http://download.ceph.com/rpm-mimic/el7/$basearch\nenabled=1\ngpgcheck=1\ntype=rpm-md\ngpgkey=https://download.ceph.com/keys/release.asc\npriority=1\n[Ceph-noarch]\nname=Ceph noarch packages\nbaseurl=http://download.ceph.com/rpm-mimic/el7/noarch\nenabled=1\ngpgcheck=1\ntype=rpm-md\ngpgkey=https://download.ceph.com/keys/release.asc\npriority=1\n[ceph-source]\nname=Ceph source packages\nbaseurl=http://download.ceph.com/rpm-mimic/el7/SRPMS\nenabled=1\ngpgcheck=1\ntype=rpm-md\ngpgkey=https://download.ceph.com/keys/release.asc\npriority=1\nHosts配置（对接openstack，同步添加openstack节点）\nhostnamectl set-hostname ceph01\ncat &gt;&gt; /etc/hosts &lt;&lt; ‘EOF’\n10.191.101.140 $HOSTNAME\n10.191.101.128 ctl01\n10.191.101.129 compute01\n10.191.101.130 neutron01\n10.191.101.131 cinder01\nEOF\n关闭selinux和防火墙\nsetenforce 0\nsed -i &#039;s/SELINUX=.*/SELINUX=disabled/&#039; /etc/selinux/config\nsystemctl stop firewalld\nsystemctl disable firewalld\nsystemctl mask firewalld\n安装软件\nyum clean all &amp;&amp; yum makecache\nyum -y install ceph-deploy epel-release python-pip ceph ceph-radosgw chrony   \n部署ceph集群\ncd /etc/ceph/\nceph-deploy new $HOSTNAME\n单节点配置需要修改配置\ncat &gt;&gt; /etc/ceph/ceph.conf &lt;&lt; EOF\nosd pool default size = 1\nosd crush chooseleaf type = 0\nosd max object name len = 256\nosd journal size = 128\nEOF\n安装ceph节点\nexport CEPH_DEPLOY_REPO_URL=http://mirrors.aliyun.com/ceph/rpm-nautilus/el7/\nexport CEPH_DEPLOY_GPG_URL=http://mirrors.aliyun.com/ceph/keys/release.asc\nceph-deploy install $HOSTNAME\n查看版本\nceph --version\n使用ceph-deploy进行部署，在更新的版本中，该工具已被弃用\n初始化监视节点和同步所有配置文件到 /etc/ceph/ 下\nceph-deploy mon create-initial\nceph-deploy admin $HOSTNAME\n节点下创建manager\nceph-deploy mgr create $HOSTNAME\n添加osd\nceph-deploy osd create --data /dev/sdX $HOSTNAME\n部署完成，检查单节点ceph部署情况\nceph -s\nDashboard配置\n在每个mgr节点安装\nyum install ceph-mgr-dashboard\n开启mgr功能\nceph mgr module enable dashboard\n生成并安装自签名的证书\nceph dashboard create-self-signed-cert\n创建一个dashboard登录用户名密码\n# 密码写入文件中，命令行从文件中读入密码\n[root@ceph01 ~]# ceph dashboard ac-user-create guest -i ceph-passwd.txt  administrator\n{&quot;username&quot;: &quot;guest&quot;, &quot;lastUpdate&quot;: 1702966284, &quot;name&quot;: null, &quot;roles&quot;: [&quot;administrator&quot;], &quot;password&quot;: &quot;$2b$12$qKgRIUT1xz41kJjeUqsQm.h.ktyN.QA4981Kw5OUoY1Ea.uCuRAA2&quot;, &quot;email&quot;: null}\n查看服务访问方式\n[root@ceph01 ~]# ceph mgr services\n{\n    &quot;dashboard&quot;: &quot;https://ceph01:8443/&quot;\n}\n# 若未配置域名解析则通过ip访问\nCeph常用命令\nOSD维护命令\n# 显示Ceph集群中的OSD树，包括每个OSD的状态和位置\nceph osd tree\n \n# 显示Ceph集群中的OSD状态摘要信息\nceph osd stat\n \n# 显示Ceph集群中的所有pool\nceph osd pool ls\n \n# 显示pool中详细的volume信息\nrbd --pool &lt;pool_name&gt; ls\n \n# 将指定的OSD标记为“离线”，从集群中排除\nceph osd out &lt;osd-id&gt;\n \n# 将指定的OSD标记为“在线”，重新加入集群\nceph osd in &lt;osd-id&gt;\n \n# 为存储池设置副本大小\nceph osd pool set &lt;pool_name&gt; size &lt;replica_size&gt;\nMonitor维护命令\n# 显示Ceph集群中监视器的状态信息\nceph mon stat\n \n# 显示Ceph集群中监视器的详细信息\nceph mon dump\n \n# 从Ceph集群中移除指定的监视器\nceph mon remove &lt;mon-id&gt;\nPG维护命令\n# 显示Ceph集群中PG（placement group）的状态信息\nceph pg stat\n\n# 修复指定的PG，解决可能的一致性问题\nceph pg repair &lt;pg-id&gt;\n\n# 对指定的PG执行“scrub”操作，检查和修复数据\nceph pg scrub &lt;pg-id&gt;\n\n健康状态命令\n# 检查Ceph集群的健康状态\nceph health\n\n# 显示详细的Ceph集群健康状态信息\nceph health detail\n\n# 运行指定的健康检查\nceph health check &lt;check-name&gt;\n\n管理Ceph配置文件\n# 显示Ceph集群的配置信息\nceph config show\n\n# 设置指定的Ceph配置项\nceph config set &lt;key&gt; &lt;value&gt;\n\n# 获取指定的Ceph配置项的值\nceph config get &lt;key&gt;\n\n常见告警处理\n1 monitors have not enabled msgr2\nceph mon enable-msgr2\n\nmsgr2是Ceph的新消息传输协议，它提供了更好的性能和安全性\n\nmon is allowing insecure global_id reclaim\n# 禁用不安全模式\n ceph config set mon auth_allow_insecure_global_id_reclaim false\n\n\n这个警告表示Ceph监视器正在允许不安全的全局ID回收。全局ID是Ceph集群中的唯一标识符，用于识别对象和其他元数据。不安全的全局ID回收可能会导致ID冲突和数据不一致的问题\n\n对接OpenStack\n\n通常，OpenStack有3个地方可以和Ceph存储进行对接：\n1、Images：OpenStack 的 Glance 管理着 VM 的 image 。Image 相对恒定，OpenStack 把它们当作二进制文件、并以此格式下载；\n2、Volumes：OpenStack 用 Cinder 服务管理 Volumes 。Volume 是块设备，OpenStack 用它们引导虚拟机、或挂载到运行中的虚拟机上；\n3、Guest Disks: Guest disks 是装有客户操作系统的磁盘。默认情况下，启动一台虚拟机时，它的系统盘表现为 hypervisor 文件系统的一个文件（通常位于 /var/lib/nova/instances/${uuid}/）；\n\n安装ini配置工具\nyum install crudini \n在glance-api的主机上安装python-rbd包\nyum install python-rbd\n在nova-compute（所有计算节点）、cinder-volume节点上安装ceph-common包\n\n在控制节点运行命令检查对应服务所在的节点\n\nopenstack volume service list\n+------------------+--------------+------+---------+-------+----------------------------+\n| Binary           | Host         | Zone | Status  | State | Updated At                 |\n+------------------+--------------+------+---------+-------+----------------------------+\n| cinder-scheduler | ctl01        | nova | enabled | up    | 2023-12-19T08:03:42.000000 |\n| cinder-volume    | cinder01@lvm | nova | enabled | up    | 2023-12-19T08:03:42.000000 |\n+------------------+--------------+------+---------+-------+----------------------------+\n\n在对应节点执行安装\n\nyum install ceph-common\n把ceph集群的/etc/ceph/ceph.conf 、/etc/ceph/ceph.client.admin.keyring 文件拷贝到以上openstack各节点的/etc/ceph目录下，确保以上openstack各对应节点成为ceph集群的客户端\n在ceph集群创建三个pool ，分别对应上文三个模块。以后所有的OpenStack虚拟机数据都会存储到这三个池中。\n创建volumes池，对应Cinder服务\nceph osd pool create os_volumes 100\n创建images池，对应Glance服务\nceph osd pool create os_images 100\n创建vms池，对应Nova服务\nceph osd pool create os_vms 100\n设置存储池副本数量\n[root@ceph01 ~]# ceph osd pool set os_vms size 1\nset pool 3 size to 1\n[root@ceph01 ~]# ceph osd pool set os_images size 1\nset pool 2 size to 1\n[root@ceph01 ~]# ceph osd pool set os_volumes size 2\nset pool 1 size to 2\n在ceph集群创建cinder、glance等用户，并做权限控制\n[root@ceph01 ~]# ceph auth get-or-create client.cinder mon &#039;allow r&#039; osd &#039;allow class-read object_prefix rbd_children, allow rwx pool=os_volumes, allow rwx pool=os_vms, allow rx pool=os_images&#039;\n[client.cinder]\n        key = AQAMVYFl0ExWCxAAT632K3WB+5VtaXh3bp8DzA==\n[root@ceph01 ~]# ceph auth get-or-create client.glance mon &#039;allow r&#039; osd &#039;allow class-read object_prefix rbd_children, allow rwx pool=os_images&#039;\n[client.glance]\n        key = AQAPVYFlceRZBBAA/V5Cg7SEC6TUZo543/H0tQ==\n \n（在ceph端执行）将上面生成的keyring文件，保存在glance和volume节点上，并修改为相应的权限\nceph auth get-or-create client.glance | ssh ctl01 sudo tee /etc/ceph/ceph.client.glance.keyring\nssh ctl01 sudo chown glance:glance /etc/ceph/ceph.client.glance.keyring\n \nceph auth get-or-create client.cinder | ssh cinder01 sudo tee /etc/ceph/ceph.client.cinder.keyring\nssh cinder01 sudo chown cinder:cinder /etc/ceph/ceph.client.cinder.keyring\n在nova-compute节点（所有计算节点）上保存和cinder-volume相同的keyring\nceph auth get-or-create client.cinder | ssh compute01 sudo tee /etc/ceph/ceph.client.cinder.keyring\nssh compute01 sudo chown nova:nova /etc/ceph/ceph.client.cinder.keyring\ncompute 节点配置\n在openstack集群所有compute节点libvirt上添加secret key\n\n从ceph集群获取cinder keyring，并保存到nova-comute对应节点/root目录下一个临时文件中\n\nceph auth get-key client.cinder | ssh compute01 tee client.cinder.key \n\n执行完后nova-compute节点的/root下会出现临时的文件\n\n\n在compute节点生成一个UUID\n\nuuidgen\n比如生成：912f054c-478b-44b7-bfc5-f0bbed491fbb\n\n/root下touch一个文件 secret.xml 内容如下：\n\n   &lt;secret ephemeral=&#039;no&#039; private=&#039;no&#039;&gt;\n          &lt;uuid&gt;912f054c-478b-44b7-bfc5-f0bbed491fbb&lt;/uuid&gt;\n          &lt;usage type=&#039;ceph&#039;&gt;\n          &lt;name&gt;client.cinder secret&lt;/name&gt;\n          &lt;/usage&gt;\n    &lt;/secret&gt;\n通过libvirt工具（virsh）定义和设置秘钥，并在设置秘钥值后删除相关的秘钥和XML文件\n[root@compute01 ~]# virsh secret-define --file secret.xml\nSecret 912f054c-478b-44b7-bfc5-f0bbed491fbb created\n \n[root@compute01 ~]# virsh secret-set-value --secret 912f054c-478b-44b7-bfc5-f0bbed491fbb --base64 $(cat client.cinder.key) &amp;&amp; rm client.cinder.key secret.xml\nSecret value set\n \nrm: remove regular file ‘client.cinder.key’? y\nrm: remove regular file ‘secret.xml’? y\n配置nova-compute节点/etc/nova/nova.conf中添加如下：\n[libvirt]\nimages_type = rbd\nimages_rbd_pool = os_vms\nimages_rbd_ceph_conf = /etc/ceph/ceph.conf\nrbd_user = cinder\nrbd_secret_uuid = 912f054c-478b-44b7-bfc5-f0bbed491fbb\ndisk_cachemodes=&quot;network=writeback&quot;\n对应节点重启服务：\nsystemctl restart openstack-nova-compute \nglance 节点配置\n配置glance节点/etc/glance/glance-api.conf对接ceph\ncrudini --set /etc/glance/glance-api.conf DEFAULT &quot;show_image_direct_url&quot; &quot;True&quot;\ncrudini --set /etc/glance/glance-api.conf glance_store &quot;default_store&quot; &quot;rbd&quot;\ncrudini --set /etc/glance/glance-api.conf glance_store &quot;rbd_store_user&quot; &quot;glance&quot;\ncrudini --set /etc/glance/glance-api.conf glance_store &quot;rbd_store_pool&quot; &quot;os_images&quot;\ncrudini --set /etc/glance/glance-api.conf glance_store &quot;stores&quot; &quot;glance.store.filesystem.Store, glance.store.http.Store, glance.store.rbd.Store&quot;\ncrudini --set /etc/glance/glance-api.conf paste_deploy &quot;flavor&quot; &quot;keystone&quot;\ncrudini --set /etc/glance/glance-api.conf glance_store &quot;rbd_store_chunk_size&quot; &quot;8&quot;\ncrudini --set /etc/glance/glance-api.conf glance_store &quot;rbd_store_ceph_conf&quot; &quot;/etc/ceph/ceph.conf&quot;\n在DEFAULT域中增加：\n[DEFAULT]\ndefault_store = rbd\n# 默认是file，要修改\n在glance_store域中增加如下，如果没有glance_store域，直接创建：\n[glance_store]\nstores = rbd\nrbd_store_pool = os_images\nrbd_store_user = glance\nrbd_store_ceph_conf = /etc/ceph/ceph.conf\nrbd_store_chunk_size = 8\n对应节点重启服务：\nsystemctl restart openstack-glance-api \ncinder 节点配置\n配置cinder节点的/etc/cinder/cinder.conf对接ceph\ncrudini --set /etc/cinder/cinder.conf DEFAULT &quot;enabled_backends&quot; &quot;lvm,ceph&quot; # 同时支持lvm、ceph\ncrudini --set /etc/cinder/cinder.conf ceph &quot;volume_driver&quot; &quot;cinder.volume.drivers.rbd.RBDDriver&quot;\ncrudini --set /etc/cinder/cinder.conf ceph &quot;volume_backend_name&quot; &quot;ceph&quot;\ncrudini --set /etc/cinder/cinder.conf ceph &quot;rbd_pool&quot; &quot;os_volumes&quot;\ncrudini --set /etc/cinder/cinder.conf ceph &quot;rbd_ceph_conf&quot; &quot;/etc/ceph/ceph.conf&quot;\ncrudini --set /etc/cinder/cinder.conf ceph &quot;rbd_flatten_volume_from_snapshot&quot; &quot;false&quot;\ncrudini --set /etc/cinder/cinder.conf ceph &quot;rbd_max_clone_depth&quot; &quot;5&quot;\ncrudini --set /etc/cinder/cinder.conf ceph &quot;rbd_store_chunk_size&quot; &quot;4&quot;\ncrudini --set /etc/cinder/cinder.conf ceph &quot;rados_connect_timeout&quot; &quot;-1&quot;\ncrudini --set /etc/cinder/cinder.conf ceph &quot;glance_api_version&quot; &quot;2&quot;\ncrudini --set /etc/cinder/cinder.conf ceph &quot;rbd_user&quot; &quot;cinder&quot;\ncrudini --set /etc/cinder/cinder.conf ceph &quot;rbd_secret_uuid&quot; &quot;912f054c-478b-44b7-bfc5-f0bbed491fbb&quot;\n对应节点重启服务：\nsystemctl restart openstack-cinder-volume \n验证\nopenstack的dashboard中测试创建卷、生成镜像和卷生成虚拟机等操作\n查看 volume service\nopenstack volume service list\n创建 volume type\nopenstack volume type create lvm"},"云计算和虚拟化/docker":{"title":"docker","links":[],"tags":["云计算和虚拟化"],"content":"拉取和推送镜像\n\n拉取镜像\n\ndocker pull &lt;镜像名称&gt;:&lt;标签&gt;\n例如，要拉取名为ubuntu的最新版本镜像，可以运行以下命令：\ndocker pull ubuntu:latest\n\n创建tag\n\ndocker tag &lt;源镜像名称&gt;:&lt;源标签&gt; &lt;目标镜像名称&gt;:&lt;目标标签&gt;\n例如，要将一个已经拉取的ubuntu:latest镜像打上my-ubuntu:v1.0的标签，可以运行以下命令：\ndocker tag ubuntu:latest my-ubuntu:v1.0\n\n推送镜像\n\ndocker push &lt;镜像名称&gt;:&lt;标签&gt;\n\n例如，要推送一个已经标记为my-ubuntu:v1.0的镜像到Docker Hub，可以运行以下命令：\ndocker push my-ubuntu:v1.0\n"},"云计算和虚拟化/k8s":{"title":"k8s","links":[],"tags":["云计算和虚拟化"],"content":"资源介绍和常用命令\nnamespace\n用于在集群中创建逻辑隔离的虚拟集群。命名空间允许将集群划分为多个独立的单元，每个单元具有自己的资源配额和访问控制策略\n查看集群所有命名空间\nkubectl get ns\n设置命名空间变量，方便使用\nOP_NAMESPACE=paas-ucrs\npod\n是Kubernetes中最小的可调度和可管理的单元。它是一个或多个容器的集合，它们共享相同的网络和存储上下文。Pod提供了一种逻辑主机，容器共享相同的IP地址和端口空间\n查看指定命名空间的所有pod\nkubectl get pods -n ${OP_NAMESPACE} \n查看pod信息\nkubectl describe pods -n ${OP_NAMESPACE} &lt;pod_name&gt;\n删除/重启pod\nkubectl delete pods -n ${OP_NAMESPACE} &lt;pod_name&gt;\n进入pod\nkubectl exec -it -n ${OP_NAMESPACE} &lt;pod_name&gt; bash\n\n查看pod最新日志，打印200行\nkubectl logs --tail=200 -n ${OP_NAMESPACE} &lt;pod_name&gt;\ndeployment\n用于定义可扩展和自愈的应用程序副本集。Deployment对应于Pod的副本控制器，它负责管理Pod的创建、更新和删除，以确保所需的副本数一直保持在活动状态\n编辑deployment\nkubectl edit deployment -n ${OP_NAMESPACE}\n删除deployment\nkubectl delete deployment -n ${OP_NAMESPACE} \n获取deployment信息，yaml格式输出\nkubectl get deployment -n ${OP_NAMESPACE} &lt;deployment_name&gt; -o yaml\n调整副本数量\nkubectl scale deployment --replicas=1 -n ${OP_NAMESPACE} &lt;deployment_name&gt;\n查看历史\nkubectl rollout history -n ${OP_NAMESPACE} deployment/&lt;deployment_name&gt;\n回滚到指定版本\nkubectl rollout undo -n ${OP_NAMESPACE} deployment/&lt;deployment_name&gt; --to-revision=&lt;num&gt;\n创建资源\nkubectl create -f &lt;filename.yml&gt;\n更新/创建资源\nkubectl apply -f &lt;filename.yml&gt;\nservice\n定义了一组Pod的访问方式和网络终结点。Service具有稳定的IP地址和DNS名称，并通过标签选择器将流量路由到后端的Pod。它可以提供负载均衡、服务发现和连接到后端应用程序的稳定入口\n编辑service\nkubectl edit service -n ${OP_NAMESPACE} &lt;service_name&gt;\nvirtualService\n查看所有vs\nkubectl get vs -A\n获取指定格式vs\nkubectl get vs -n &lt;nsname&gt; &lt;vsname&gt; -o yaml\n编辑vs\nkubectl edit vs -n &lt;nsname&gt; &lt;vsname&gt;\n\nconfigMap\n于将非敏感的配置数据注入到Pod中。ConfigMap可以存储键值对、文件或目录，并可以在Pod中以环境变量、命令行参数或卷的形式使用\n创建cm\nkubectl create configmap -n ${OP_NAMESPACE} &lt;cmname&gt; --from-file=&lt;filepath&gt;\n编辑cm\nkubectl edit configmap -n ${OP_NAMESPACE} &lt;cmname&gt;\n删除cm\nkubectl delete configmap -n ${OP_NAMESPACE} &lt;cmname&gt;\nimage\n更新镜像\nkubectl set image deploy -n ${OP_NAMESPACE} &lt;deployment_name&gt; *=&lt;image_url&gt;\n查看镜像版本，使用jsonpath模板来按指定格式输出结果\nkubectl get pods -n ${OP_NAMESPACE}  -o=jsonpath=&#039;{range .items[*]}{.metadata.name}{&quot;\\t&quot;}{.spec.containers[*].image}{&quot;\\n&quot;}{end}&#039;\n\nkubectl get pods -n ${OP_NAMESPACE}: 用于获取指定命名空间（${OP_NAMESPACE}）中的所有Pods的信息\n-o=jsonpath=&#039;{range .items[*]}{.metadata.name}{&quot;\\t&quot;}{.spec.containers[*].image}{&quot;\\n&quot;}{end}&#039;: 使用jsonpath模板来输出结果\n&#039;{range .items[*]}:使用range关键字来迭代所有的Pods对象\n{.metadata.name}: 输出每个Pod的名称\n{&quot;\\t&quot;}: 在名称和镜像之间添加一个水平制表符\n{.spec.containers[*].image}: 输出每个Pod中所有容器的镜像信息\n{&quot;\\n&quot;}: 在每个Pod的信息之间添加一个换行符\n{end}: 结束range循环\n\n综合起来，命令将输出指定命名空间中所有Pods的名称和每个Pod中所有容器的镜像信息，每个Pod的信息用制表符分隔，每个Pod之间用换行符分隔\nstatefulSet\n用于管理有状态应用程序的副本集。StatefulSet为每个Pod分配唯一的标识符和网络标识，以便在Pod重新启动或扩展时保持稳定\nsecret\n用于安全地存储敏感信息，如密码、API密钥等。Secret以Base64编码的形式存储，并可以在Pod中以环境变量、命令行参数或卷的形式使用\npersistentVolume\n用于将持久化存储资源抽象为Kubernetes中的卷。它独立于Pod的生命周期，并提供了持久性和数据的跨Pod共享\njob\n用于在集群中运行一次性任务或批处理任务。它确保任务成功完成，并且可以设置重试和并行性。Job创建一个或多个Pod来运行任务，当任务完成时，它们会自动终止。Job适用于需要执行一次性任务或需要确保任务的完整性的场景\ncronJob\n基于类似于Unix cron的时间表达式来定期运行任务。它创建一个Job来运行预定义的任务，并可以设置任务的调度时间和重试策略。CronJob适用于需要定期执行的任务，如定时备份、数据清理等\ningress\n将外部流量路由到集群内部服务的规则和配置。它充当了外部流量的入口点，并提供负载均衡、SSL终止和基于域名的路由等功能。Ingress通过定义规则和使用反向代理来将外部请求路由到相应的服务。它可以与不同的Ingress控制器配合使用，如Nginx Ingress Controller、Traefik等"},"云计算和虚拟化/openstack":{"title":"openstack","links":[],"tags":["云计算和虚拟化"],"content":"openstack集群健康检查\nopenstack-status"},"云计算和虚拟化/云计算和虚拟化":{"title":"云计算和虚拟化","links":[],"tags":[],"content":"\n\n云计算和虚拟化\n\n云计算基础概念和服务模型（如 IaaS、PaaS、SaaS）\n虚拟化技术（如 VMware、KVM、Docker）\n容器编排和管理工具（如 Kubernetes）\n\n\n"},"基础技能/go":{"title":"go","links":[],"tags":["基础技能"],"content":"跨平台代码\n典型“动态语言思维”的错误\nif runtime.GOOS == &quot;windows&quot; { return nil }\n......\n该方式仅在编译完成后执行时进行操作系统的判断，但在编译时如果代码中引用了该平台不支持的调用，会导致无法编译。\n条件编译\nGo使用构建标签(build tags)和代码文件的命名约定来支持Go软件包的条件编译\n构建标签\n构建标签必须在代码文件里位于package声明的上方，并且后跟一个空行。\n构建标签遵循以下三个原则：\n\n空格隔开的选项是或（OR）的关系\n逗号隔开的选项是与（AND）的关系\n每个选项由字母和数字组成。如果前面加上!，则表示反义\n\n如下例子表示该文件将在linux/386或darwin/386平台才会被编译，用逻辑表达式表示就是：(linux OR darwin) AND 386\n// +build linux darwin\n// +build 386\n文件名后缀\n通过源码文件的文件名实现，如果文件名包含_$GOOS.go后缀，那么这个源码文件只会在对应的平台被编译。其他平台会忽略这个文件。另一种约定是_$GOARCH.go。这两种后缀可以组合起来，但要保证顺序，正确的格式是_$GOOS_$GOARCH.go，错误的格式是_$GOARCH_$GOOS.go\nmypkg_freebsd_arm.go // 只在 freebsd/arm 系统编译\nmypkg_plan9.go       // 只在 plan9 编译\nmypkg_darwin.go      // 只在macos 系统编译\n如何选择\n通常来说，当只有一个特定平台或体系需要指定时，我们选择文件名后缀的方式，相反，如果文件需要指定给多个平台或体系架构使用，或者需要排除某个特定平台时，选择构建标签的方式\nmypkg_linux.go         // 只在 linux 系统编译\nmypkg_windows_amd64.go // 只在 windows amd 64位 平台编译\n// 在所有类unix平台编译\n// +build darwin dragonfly freebsd linux netbsd openbsd\n \n// 在非Windows平台编译\n// +build !windows\n执行交叉编译\n在编译时给go build命令设置OS和ARCH参数\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go\n参考链接：https://juejin.cn/post/6874561730149384200 作者：kevinyan"},"基础技能/python":{"title":"python","links":[],"tags":["基础技能"],"content":"初识Python\n版本\n版本号分为三段，形如A.B.C，版本大更新增加A，新功能增加B，小改动增加C\n优缺点\n优点\n\n简单，学习曲线低\n开放源代码，生态强大\n解释型语言移植性强\n支持面向对象和函数式编程\n代码规范可读性强\n\n缺点\n\n执行效率稍微低\n代码无法加密\n\n解释器\n官方的Python解释器是用C语言实现的，也是使用最为广泛的Python解释器，通常称之为CPython\n应用领域\n后端开发、DevOps、爬虫、自动化测试、数据分析、机器学习\n运行\n单行注释以#开头，多行注释以&#039;&#039;&#039;开头和结尾\n# hello world 示例\nprint(&#039;hello, world!&#039;)\n开发工具\n安装python 自带集成开发工具IDLE（命令行交互式），实际开发不方便使用，通常使用pycharm或者vscode\n语言元素\n以python3进行总结\n\n整型 int 0b100 0x100 0o100\n浮点型 123.456\n字符串 “hello”\n布尔 true和false\n复数 与数学的i不同，使用j表示\n\n在python中可以使用type函数对类型进行检查\na = 100\nb = 12.345\nc = 1 + 5j\nd = &#039;hello, world&#039;\ne = True\nprint(type(a))    # &lt;class &#039;int&#039;&gt;\nprint(type(b))    # &lt;class &#039;float&#039;&gt;\nprint(type(c))    # &lt;class &#039;complex&#039;&gt;\nprint(type(d))    # &lt;class &#039;str&#039;&gt;\nprint(type(e))    # &lt;class &#039;bool&#039;&gt;\n变量命名\n硬性规则\n\n字母、数字和下划线，数字不开头\n大小写敏感\n关键词和系统保留字不可用\n\nPEP 8要求\n\n小写字母，多个单词使用下划线\n受保护实例属性下划线开头\n私有实例属性两个下划线开头\n\n运算符\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符描述[] [:]下标，切片**指数~ + -按位取反, 正负号* / % //乘，除，模，整除+ -加，减&gt;&gt; &lt;&lt;右移，左移&amp;按位与^ |按位异或，按位或&lt;= &lt; &gt; &gt;=小于等于，小于，大于，大于等于== !=等于，不等于is is not身份运算符in not in成员运算符not or and逻辑运算符= += -= *= /= %= //= **= &amp;=运算赋值\n分支结构\nif x &gt; 1:\n    y = 3 * x - 5\nelif x &gt;= -1:\n    y = x + 2\nelse:\n    y = 5 * x + 3\n循环结构\nfor x in range(101):\n    sum += x\n\n\nrange(1, 101, 2) 产生1到100的奇数，2是步长\n\nwhile True:\n    number = int(input(&#039;请输入: &#039;))\n    if number &lt; 1:\n        print(&#039;1&#039;)\n    elif number &gt; 1:\n        print(&#039;0&#039;)\n    else:\n        print(&#039;-1&#039;)\n        break\nbreak终止所在的循环, continue放弃本次循环后续的代码\n函数和模块\ndef关键字定义函数，return关键字返回值\ndef fac(num):\n    &quot;&quot;&quot;求阶乘&quot;&quot;&quot;\n    result = 1\n    for n in range(1, num + 1):\n        result *= n\n    return result\n函数参数\nPython中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载\nfrom random import randint\n \n \ndef roll_dice(n=2):\n    &quot;&quot;&quot;摇色子&quot;&quot;&quot;\n    total = 0\n    for _ in range(n):\n        total += randint(1, 6)\n    return total\n \n \ndef add(a=0, b=0, c=0):\n    &quot;&quot;&quot;三个数相加&quot;&quot;&quot;\n    return a + b + c\n \n \n# 如果没有指定参数那么使用默认值摇两颗色子\nprint(roll_dice())\n# 摇三颗色子\nprint(roll_dice(3))\nprint(add())\nprint(add(1))\nprint(add(1, 2))\nprint(add(1, 2, 3))\n# 传递参数时可以不按照设定的顺序进行传递\nprint(add(c=50, a=100, b=200))\n如果会对0个或多个参数进行加法运算，在不确定参数个数的时候，可以使用可变参数\n# 在参数名前面的*表示args是一个可变参数\ndef add(*args):\n    total = 0\n    for val in args:\n        total += val\n    return total\n \n \n# 在调用add函数时可以传入0个或多个参数\nprint(add())\nprint(add(1))\nprint(add(1, 2))\nprint(add(1, 2, 3))\nprint(add(1, 3, 5, 7, 9))\n模块管理函数\n如果在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的\ndef foo():\n    print(&#039;hello, world!&#039;)\n \n \ndef foo():\n    print(&#039;goodbye, world!&#039;)\n \n \n# 下面的代码会输出什么呢？\nfoo()\nPython中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数\nimport module1 as m1\nimport module2 as m2\n \nm1.foo()\nm2.foo()\n如果导入的模块除了定义函数之外还有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是”__main__”\ndef foo():\n    pass\n \n \ndef bar():\n    pass\n \n \n# __name__是Python中一个隐含的变量它代表了模块的名字\n# 只有被Python解释器直接执行的模块的名字才是__main__\nif __name__ == &#039;__main__&#039;:\n    print(&#039;call foo()&#039;)\n    foo()\n    print(&#039;call bar()&#039;)\n    bar()\n作用域\nPython查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索\ndef foo():\n    global a\n    a = 200\n    print(a)  # 200\n \n \nif __name__ == &#039;__main__&#039;:\n    a = 100\n    foo()\n    print(a)  # 200\n使用global关键字来指示函数中的变量来自于全局作用域，如果希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域，在实际开发中，应该尽量减少对全局变量的使用\n如果希望将一个局部变量的生命周期延长，使其在定义它的函数调用结束后依然可以使用它的值，这时候就需要使用闭包\n说明： 很多人经常会将“闭包”和“匿名函数”混为一谈，但实际上它们并不是一回事，如果想了解这个概念，可以看看维基百科的解释或者知乎上对这个概念的讨论\n字符串和常用数据结构\n数值类型是标量类型，也就是说这种类型的对象没有可以访问的内部结构；而字符串类型是一种结构化的、非标量类型，所以才会有一系列的属性和方法\n定义列表可以将列表的元素放在[]中，多个元素用,进行分隔，可以使用for循环对列表元素进行遍历，也可以使用[]或[:]运算符取出列表中的一个或多个元素\n生成式和生成器\nf = [x for x in range(1, 10)]\nprint(f)\nf = [x + y for x in &#039;ABCDE&#039; for y in &#039;1234567&#039;]\nprint(f)\n# 用列表的生成表达式语法创建列表容器\n# 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间\nf = [x ** 2 for x in range(1, 1000)]\nprint(sys.getsizeof(f))  # 查看对象占用内存的字节数\nprint(f)\n# 请注意下面的代码创建的不是一个列表而是一个生成器对象\n# 通过生成器可以获取到数据但它不占用额外的空间存储数据\n# 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)\nf = (x ** 2 for x in range(1, 1000))\nprint(sys.getsizeof(f))  # 相比生成式生成器不占用存储数据的空间\nprint(f)\nfor val in f:\n    print(val)\nPython中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数，示例斐波拉切数列的生成器\ndef fib(n):  \n    a, b = 0, 1  \n    for _ in range(n):  \n        a, b = b, a + b  \n        yield a  \n  \n  \ndef main():  \n    for val in fib(20):  \n        print(val)  \n  \n  \nif __name__ == &#039;__main__&#039;:  \n    main()  \n  \n# 执行结果  \n# n=0,a=0,b=1  \n# n=1,a=1,b=1  \n# n=2,a=1,b=2  \n# n=3,a=2,b=3  \n# n=4,a=3,b=5\n# ...\n当执行到 yield a 语句时，生成器函数会暂停执行，并将当前的 a 值作为生成的值返回给调用者。此时，生成器函数的状态被冻结，等待下一次调用。\n调用生成器函数时，会返回一个生成器对象。生成器对象可以被迭代，每次迭代时，生成器函数会从上一次暂停的位置继续执行，直到遇到下一个 yield 语句，然后再次暂停，将生成的值返回给调用者。\n元组\nPython中的元组与列表类似也是一种容器数据类型，可以用一个变量（对象）来存储多个数据，不同之处在于元组的元素不能修改\n# 定义元组\nt = (&#039;骆昊&#039;, 38, True, &#039;四川成都&#039;)\nprint(t)\n# 获取元组中的元素\nprint(t[0])\nprint(t[3])\n# 遍历元组中的值\nfor member in t:\n    print(member)\n# 重新给元组赋值\n# t[0] = &#039;王大锤&#039;  # TypeError: &#039;tuple&#039; object does not support item assignment\nt = (&#039;王大锤&#039;, 20, True, &#039;云南昆明&#039;) # 变量t重新引用了新的元组,原来的元组将被垃圾回收\nprint(t)\n# 将元组转换成列表\nperson = list(t)\nprint(person)\n# 列表是可以修改它的元素的\nperson[0] = &#039;李小龙&#039;\nperson[1] = 25\nprint(person)\n# 将列表转换成元组\nfruits_list = [&#039;apple&#039;, &#039;banana&#039;, &#039;orange&#039;]\nfruits_tuple = tuple(fruits_list)\nprint(fruits_tuple)\n集合\nPython中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算\n# 创建集合的字面量语法\nset1 = {1, 2, 3, 3, 3, 2}\nprint(set1)\nprint(&#039;Length =&#039;, len(set1))\n# 创建集合的构造器语法(面向对象部分会进行详细讲解)\nset2 = set(range(1, 10))\nset3 = set((1, 2, 3, 3, 2, 1))\nprint(set2, set3)\n# 创建集合的推导式语法(推导式也可以用于推导集合)\nset4 = {num for num in range(1, 100) if num % 3 == 0 or num % 5 == 0}\nprint(set4)\n字典\n字典是另一种可变容器模型，Python中的字典跟我们生活中使用的字典是一样一样的，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开\n# 创建字典的字面量语法\nscores = {&#039;骆昊&#039;: 95, &#039;白元芳&#039;: 78, &#039;狄仁杰&#039;: 82}\nprint(scores)\n# 创建字典的构造器语法\nitems1 = dict(one=1, two=2, three=3, four=4)\n# 通过zip函数将两个序列压成字典\nitems2 = dict(zip([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;], &#039;123&#039;))\n# 创建字典的推导式语法\nitems3 = {num: num ** 2 for num in range(1, 10)}\nprint(items1, items2, items3)\n# 通过键可以获取字典中对应的值\nprint(scores[&#039;骆昊&#039;])\nprint(scores[&#039;狄仁杰&#039;])\n# 对字典中所有键值对进行遍历\nfor key in scores:\n    print(f&#039;{key}: {scores[key]}&#039;)\n# 更新字典中的元素\nscores[&#039;白元芳&#039;] = 65\nscores[&#039;诸葛王朗&#039;] = 71\nscores.update(冷面=67, 方启鹤=85)\nprint(scores)\nif &#039;武则天&#039; in scores:\n    print(scores[&#039;武则天&#039;])\nprint(scores.get(&#039;武则天&#039;))\n# get方法也是通过键获取对应的值但是可以设置默认值\nprint(scores.get(&#039;武则天&#039;, 60))\n# 删除字典中的元素\nprint(scores.popitem())\nprint(scores.popitem())\nprint(scores.pop(&#039;骆昊&#039;, 100))\n# 清空字典\nscores.clear()\nprint(scores)\n面向对象基础\n把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派\n在Python中可以使用class关键字定义类，然后在类中通过函数来定义方法，这样就可以将对象的动态特征描述出来\n定义类\n在 Python 3.x 中，所有的类都默认继承自 object，无论是否显式地指定，这意味着在 Python 3.x 中，可以省略 object，因为它是默认的基类\nclass Student(object):\n\n    # __init__是一个特殊方法用于在创建对象时进行初始化操作\n    # 通过这个方法我们可以为学生对象绑定name和age两个属性\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def study(self, course_name):\n        print(&#039;%s正在学习%s.&#039; % (self.name, course_name))\n\n    # PEP 8要求标识符的名字用全小写多个单词用下划线连接\n    # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)\n    def watch_movie(self):\n        if self.age &lt; 18:\n            print(&#039;%s只能观看《熊出没》.&#039; % self.name)\n        else:\n            print(&#039;%s正在观看岛国爱情大电影.&#039; % self.name)\n\n说明： 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息\n创建使用\ndef main():\n    # 创建学生对象并指定姓名和年龄\n    stu1 = Student(&#039;骆昊&#039;, 38)\n    # 给对象发study消息\n    stu1.study(&#039;Python程序设计&#039;)\n    # 给对象发watch_av消息\n    stu1.watch_movie()\n    stu2 = Student(&#039;王大锤&#039;, 15)\n    stu2.study(&#039;思想品德&#039;)\n    stu2.watch_movie()\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n访问可见性\n在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头\nPython并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们\n面向对象支柱\n\n封装：将数据和对数据的操作封装在对象中，通过对象的方法来访问和修改数据\n继承：通过继承创建新的类，子类可以继承父类的属性和方法，并且可以覆盖或扩展它们\n多态：同一个方法可以在不同的对象上产生不同的行为\n\n面向对象进阶\n@property装饰器\n虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如没有办法检查赋给属性的值是否有效。之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便\nclass Person(object):\n\n    def __init__(self, name, age):\n        self._name = name\n        self._age = age\n\n    # 访问器 - getter方法\n    @property\n    def name(self):\n        return self._name\n\n    # 访问器 - getter方法\n    @property\n    def age(self):\n        return self._age\n\n    # 修改器 - setter方法\n    @age.setter\n    def age(self, age):\n        self._age = age\n\n    def play(self):\n        if self._age &lt;= 16:\n            print(&#039;%s正在玩飞行棋.&#039; % self._name)\n        else:\n            print(&#039;%s正在玩斗地主.&#039; % self._name)\n\n\ndef main():\n    person = Person(&#039;王大锤&#039;, 12)\n    person.play()\n    person.age = 22\n    person.play()\n    # person.name = &#039;白元芳&#039;  # AttributeError: can&#039;t set attribute\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n__slots__魔法\nPython是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用\nclass Person(object):\n\n    # 限定Person对象只能绑定_name, _age和_gender属性\n    __slots__ = (&#039;_name&#039;, &#039;_age&#039;, &#039;_gender&#039;)\n\n    def __init__(self, name, age):\n        self._name = name\n        self._age = age\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def age(self):\n        return self._age\n\n    @age.setter\n    def age(self, age):\n        self._age = age\n\n    def play(self):\n        if self._age &lt;= 16:\n            print(&#039;%s正在玩飞行棋.&#039; % self._name)\n        else:\n            print(&#039;%s正在玩斗地主.&#039; % self._name)\n\n\ndef main():\n    person = Person(&#039;王大锤&#039;, 22)\n    person.play()\n    person._gender = &#039;男&#039;\n    # AttributeError: &#039;Person&#039; object has no attribute &#039;_is_gay&#039;\n    # person._is_gay = True\n\n静态方法和类方法\n之前在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，写在类中的方法并不需要都是对象方法，例如定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。可以使用静态方法来解决这类问题\nfrom math import sqrt\n\n\nclass Triangle(object):\n\n    def __init__(self, a, b, c):\n        self._a = a\n        self._b = b\n        self._c = c\n\n    @staticmethod\n    def is_valid(a, b, c):\n        return a + b &gt; c and b + c &gt; a and a + c &gt; b\n\n    def perimeter(self):\n        return self._a + self._b + self._c\n\n    def area(self):\n        half = self.perimeter() / 2\n        return sqrt(half * (half - self._a) *\n                    (half - self._b) * (half - self._c))\n\n\ndef main():\n    a, b, c = 3, 4, 5\n    # 静态方法和类方法都是通过给类发消息来调用的\n    if Triangle.is_valid(a, b, c):\n        t = Triangle(a, b, c)\n        print(t.perimeter())\n        # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数\n        # print(Triangle.perimeter(t))\n        print(t.area())\n        # print(Triangle.area(t))\n    else:\n        print(&#039;无法构成三角形.&#039;)\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象\nfrom time import time, localtime, sleep\n\n\nclass Clock(object):\n    &quot;&quot;&quot;数字时钟&quot;&quot;&quot;\n\n    def __init__(self, hour=0, minute=0, second=0):\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n\n    @classmethod\n    def now(cls):\n        ctime = localtime(time())\n        return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)\n\n    def run(self):\n        &quot;&quot;&quot;走字&quot;&quot;&quot;\n        self._second += 1\n        if self._second == 60:\n            self._second = 0\n            self._minute += 1\n            if self._minute == 60:\n                self._minute = 0\n                self._hour += 1\n                if self._hour == 24:\n                    self._hour = 0\n\n    def show(self):\n        &quot;&quot;&quot;显示时间&quot;&quot;&quot;\n        return &#039;%02d:%02d:%02d&#039; % \\\n               (self._hour, self._minute, self._second)\n\n\ndef main():\n    # 通过类方法创建对象并获取系统时间\n    clock = Clock.now()\n    while True:\n        print(clock.show())\n        sleep(1)\n        clock.run()\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n类之间的关系\n简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系\n\nis-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系\nhas-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系\nuse-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系\n\n继承和多态\n可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则\nclass Person(object):\n    &quot;&quot;&quot;人&quot;&quot;&quot;\n\n    def __init__(self, name, age):\n        self._name = name\n        self._age = age\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def age(self):\n        return self._age\n\n    @age.setter\n    def age(self, age):\n        self._age = age\n\n    def play(self):\n        print(&#039;%s正在愉快的玩耍.&#039; % self._name)\n\n    def watch_av(self):\n        if self._age &gt;= 18:\n            print(&#039;%s正在观看爱情动作片.&#039; % self._name)\n        else:\n            print(&#039;%s只能观看《熊出没》.&#039; % self._name)\n\n\nclass Student(Person):\n    &quot;&quot;&quot;学生&quot;&quot;&quot;\n\n    def __init__(self, name, age, grade):\n        super().__init__(name, age)\n        self._grade = grade\n\n    @property\n    def grade(self):\n        return self._grade\n\n    @grade.setter\n    def grade(self, grade):\n        self._grade = grade\n\n    def study(self, course):\n        print(&#039;%s的%s正在学习%s.&#039; % (self._grade, self._name, course))\n\n\nclass Teacher(Person):\n    &quot;&quot;&quot;老师&quot;&quot;&quot;\n\n    def __init__(self, name, age, title):\n        super().__init__(name, age)\n        self._title = title\n\n    @property\n    def title(self):\n        return self._title\n\n    @title.setter\n    def title(self, title):\n        self._title = title\n\n    def teach(self, course):\n        print(&#039;%s%s正在讲%s.&#039; % (self._name, self._title, course))\n\n\ndef main():\n    stu = Student(&#039;王大锤&#039;, 15, &#039;初三&#039;)\n    stu.study(&#039;数学&#039;)\n    stu.watch_av()\n    t = Teacher(&#039;骆昊&#039;, 38, &#039;砖家&#039;)\n    t.teach(&#039;Python程序设计&#039;)\n    t.watch_av()\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）\nfrom abc import ABCMeta, abstractmethod\n\n\nclass Pet(object, metaclass=ABCMeta):\n    &quot;&quot;&quot;宠物&quot;&quot;&quot;\n\n    def __init__(self, nickname):\n        self._nickname = nickname\n\n    @abstractmethod\n    def make_voice(self):\n        &quot;&quot;&quot;发出声音&quot;&quot;&quot;\n        pass\n\n\nclass Dog(Pet):\n    &quot;&quot;&quot;狗&quot;&quot;&quot;\n\n    def make_voice(self):\n        print(&#039;%s: 汪汪汪...&#039; % self._nickname)\n\n\nclass Cat(Pet):\n    &quot;&quot;&quot;猫&quot;&quot;&quot;\n\n    def make_voice(self):\n        print(&#039;%s: 喵...喵...&#039; % self._nickname)\n\n\ndef main():\n    pets = [Dog(&#039;旺财&#039;), Cat(&#039;凯蒂&#039;), Dog(&#039;大黄&#039;)]\n    for pet in pets:\n        pet.make_voice()\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n在上面的代码中，将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）\n文件和异常\nPython内置的open函数，可以指定文件名、操作模式、编码信息等来获得操作文件的对象\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n操作模式具体含义&#039;r&#039;读取 （默认）&#039;w&#039;写入（会先截断之前的内容）&#039;x&#039;写入，如果文件已经存在会产生异常&#039;a&#039;追加，将内容写入到已有文件的末尾&#039;b&#039;二进制模式&#039;t&#039;文本模式（默认）&#039;+&#039;更新（既可以读又可以写）\ndef main():\n    f = None\n    try:\n        f = open(&#039;致橡树.txt&#039;, &#039;r&#039;, encoding=&#039;utf-8&#039;)\n        print(f.read())\n    except FileNotFoundError:\n        print(&#039;无法打开指定的文件!&#039;)\n    except LookupError:\n        print(&#039;指定了未知的编码!&#039;)\n    except UnicodeDecodeError:\n        print(&#039;读取文件时解码错误!&#039;)\n    finally:\n        if f:\n            f.close()\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n除了使用文件对象的read方法读取文件之外，还可以使用for-in循环逐行读取或者用readlines方法将文件按行读取到一个列表容器中\n字符串和正则\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n符号解释示例说明.匹配任意字符b.t可以匹配bat / but / b#t / b1t等\\w匹配字母/数字/下划线b\\wt可以匹配bat / b1t / b_t等  但不能匹配b#t\\s匹配空白字符（包括\\r、\\n、\\t等）love\\syou可以匹配love you\\d匹配数字\\d\\d可以匹配01 / 23 / 99等\\b匹配单词的边界\\bThe\\b^匹配字符串的开始^The可以匹配The开头的字符串$匹配字符串的结束.exe$可以匹配.exe结尾的字符串\\W匹配非字母/数字/下划线b\\Wt可以匹配b#t / b@t等  但不能匹配but / b1t / b_t等\\S匹配非空白字符love\\Syou可以匹配love#you等  但不能匹配love you\\D匹配非数字\\d\\D可以匹配9a / 3# / 0F等\\B匹配非单词边界\\Bio\\B[]匹配来自字符集的任意单一字符[aeiou]可以匹配任一元音字母字符[^]匹配不在字符集中的任意单一字符[^aeiou]可以匹配任一非元音字母字符*匹配0次或多次\\w*+匹配1次或多次\\w+?匹配0次或1次\\w?{N}匹配N次\\w{3}{M,}匹配至少M次\\w{3,}{M,N}匹配至少M次至多N次\\w{3,6}|分支foo|bar可以匹配foo或者bar(?#)注释(exp)匹配exp并捕获到自动命名的组中(?exp)匹配exp并捕获到名为name的组中(?:exp)匹配exp但是不捕获匹配的文本(?=exp)匹配exp前面的位置\\b\\w+(?=ing)可以匹配I’m dancing中的danc(?⇐exp)匹配exp后面的位置(?⇐\\bdanc)\\w+\\b可以匹配I love dancing and reading中的第一个ing(?!exp)匹配后面不是exp的位置(?&lt;!exp)匹配前面不是exp的位置*?重复任意次，但尽可能少重复a.b  a.?b将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串+?重复1次或多次，但尽可能少重复??重复0次或1次，但尽可能少重复{M,N}?重复M到N次，但尽可能少重复{M,}?重复M次以上，但尽可能少重复\npython对正则的支持\nPython提供了re模块来支持正则表达式相关操作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明compile(pattern, flags=0)编译正则表达式返回正则表达式对象match(pattern, string, flags=0)用正则表达式匹配字符串 成功返回匹配对象 否则返回Nonesearch(pattern, string, flags=0)搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回Nonesplit(pattern, string, maxsplit=0, flags=0)用正则表达式指定的模式分隔符拆分字符串 返回列表sub(pattern, repl, string, count=0, flags=0)用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数fullmatch(pattern, string, flags=0)match函数的完全匹配（从字符串开头到结尾）版本findall(pattern, string, flags=0)查找字符串所有与正则表达式匹配的模式 返回字符串的列表finditer(pattern, string, flags=0)查找字符串所有与正则表达式匹配的模式 返回一个迭代器purge()清除隐式编译的正则表达式的缓存re.I / re.IGNORECASE忽略大小写匹配标记re.M / re.MULTILINE多行匹配标记\n进程和线程\n进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间\n一个进程可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程\nPython既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程\n多进程\nUnix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。fork()函数非常特殊它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了fork()函数。由于Windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（Pool）、用于进程间通信的队列（Queue）和管道（Pipe）等\nfrom multiprocessing import Process\nfrom os import getpid\nfrom random import randint\nfrom time import time, sleep\n\n\ndef download_task(filename):\n    print(&#039;启动下载进程，进程号[%d].&#039; % getpid())\n    print(&#039;开始下载%s...&#039; % filename)\n    time_to_download = randint(5, 10)\n    sleep(time_to_download)\n    print(&#039;%s下载完成! 耗费了%d秒&#039; % (filename, time_to_download))\n\n\ndef main():\n    start = time()\n    p1 = Process(target=download_task, args=(&#039;Python从入门到住院.pdf&#039;, ))\n    p1.start()\n    p2 = Process(target=download_task, args=(&#039;Peking Hot.avi&#039;, ))\n    p2.start()\n    p1.join()\n    p2.join()\n    end = time()\n    print(&#039;总共耗费了%.2f秒.&#039; % (end - start))\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n上面的代码中，通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，而join方法表示等待进程执行结束，也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信\n多线程\n在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装\n可以直接使用threading模块的Thread类来创建线程，也可以从已有的类创建新类，通过继承Thread类的方式来创建自定义的线程类\nfrom random import randint\nfrom threading import Thread\nfrom time import time, sleep\n\n\nclass DownloadTask(Thread):\n\n    def __init__(self, filename):\n        super().__init__()\n        self._filename = filename\n\n    def run(self):\n        print(&#039;开始下载%s...&#039; % self._filename)\n        time_to_download = randint(5, 10)\n        sleep(time_to_download)\n        print(&#039;%s下载完成! 耗费了%d秒&#039; % (self._filename, time_to_download))\n\n\ndef main():\n    start = time()\n    t1 = DownloadTask(&#039;Python从入门到住院.pdf&#039;)\n    t1.start()\n    t2 = DownloadTask(&#039;Peking Hot.avi&#039;)\n    t2.start()\n    t1.join()\n    t2.join()\n    end = time()\n    print(&#039;总共耗费了%.2f秒.&#039; % (end - start))\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n网络编程入门\n网络协议的三要素是：语法、语义和时序。构成我们今天使用的Internet的基础的是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，通常也把这套东西称为TCP/IP模型。与国际标准化组织发布的OSI/RM这个七层模型不同，TCP/IP是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层\nTCP全称传输控制协议\n\n数据不传丢不传错（利用握手、校验和重传机制可以实现）\n流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）\n拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）\n\n网络应用模式\n\nC/S模式和B/S模式。这里的C指的是Client（客户端），B指的是Browser（浏览器）\n去中心化的网络应用模式\n\n基于传输层协议的套接字编程\n套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用\nTCP套接字\n所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务\n一个提供时间日期的服务器\nfrom socket import socket, SOCK_STREAM, AF_INET\nfrom datetime import datetime\n\n\ndef main():\n    # 1.创建套接字对象并指定使用哪种传输服务\n    # family=AF_INET - IPv4地址\n    # family=AF_INET6 - IPv6地址\n    # type=SOCK_STREAM - TCP套接字\n    # type=SOCK_DGRAM - UDP套接字\n    # type=SOCK_RAW - 原始套接字\n    server = socket(family=AF_INET, type=SOCK_STREAM)\n    # 2.绑定IP地址和端口(端口用于区分不同的服务)\n    # 同一时间在同一个端口上只能绑定一个服务否则报错\n    server.bind((&#039;192.168.1.2&#039;, 6789))\n    # 3.开启监听 - 监听客户端连接到服务器\n    # 参数512可以理解为连接队列的大小\n    server.listen(512)\n    print(&#039;服务器启动开始监听...&#039;)\n    while True:\n        # 4.通过循环接收客户端的连接并作出相应的处理(提供服务)\n        # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行\n        # accept方法返回一个元组其中的第一个元素是客户端对象\n        # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成)\n        client, addr = server.accept()\n        print(str(addr) + &#039;连接到了服务器.&#039;)\n        # 5.发送数据\n        client.send(str(datetime.now()).encode(&#039;utf-8&#039;))\n        # 6.断开连接\n        client.close()\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\nfrom socket import socket\n\n\ndef main():\n    # 1.创建套接字对象默认使用IPv4和TCP协议\n    client = socket()\n    # 2.连接到服务器(需要指定IP地址和端口)\n    client.connect((&#039;192.168.1.2&#039;, 6789))\n    # 3.从服务器接收数据\n    print(client.recv(1024).decode(&#039;utf-8&#039;))\n    client.close()\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\nUDP套接字\n传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的\n图像和文档处理\n用程序来处理图像和办公文档经常出现在实际开发中，Python的标准库中虽然没有直接支持这些操作的模块，但我们可以通过Python生态圈中的第三方模块来完成这些操作"},"基础技能/shell":{"title":"shell","links":[],"tags":["基础技能"],"content":"下载命令\ncurl\ncurl --fail --retry 0 --connect-timeout 1 --max-time 3 --retry-delay 1 --remote-time --silent -o - &quot;$url&quot;\n\n--fail：如果请求失败（例如HTTP状态码不是2xx），curl会返回非零退出码。\n--retry 0：设置最大重试次数为0次。如果下载失败，curl 不会进行重试。\n--connect-timeout 1：设置连接超时时间为1秒。如果连接超过1秒仍未建立，curl 将退出并认为连接失败。\n--max-time 3：设置总体超时时间为3秒。如果下载超过3秒仍未完成，curl 将退出并认为下载失败。\n--retry-delay 1：设置重试之间的等待时间为1秒。这样可以在尝试下载之间增加一些延迟，以降低对服务器的负载。\n--remote-time：将远程文件的时间戳设置为本地文件的时间戳。这样可以确保只下载更新的文件。\n--silent：静默模式，禁止显示进度和其他信息。\n-o -：将远程文件保存到标准输出（stdout），而不是保存到文件中。\n\n短命令\ncurl -f -s -m 3 -z &quot;$local_file&quot; -o &quot;$output_file&quot; &quot;$url&quot;\n\n-f：如果请求失败（例如HTTP状态码不是2xx），则curl会返回非零退出码。\n-s：静默模式，禁止显示进度和其他信息。\n-m 3：设置总体超时时间为3秒。如果下载超过3秒仍未完成，curl将退出并认为下载失败。\n-z &quot;$url&quot;：指定一个时间戳，表示只下载比该时间戳更新的文件。\n-o output_file：将下载的内容保存到指定的文件中。\n\n时间戳\ncurl --fail --retry 0 --connect-timeout 1 --max-time 3 --retry-delay 1 --remote-time --silent --time-cond &quot;$(echo &quot;${url}&quot; | xargs basename)&quot; -O &quot;${url}&quot;\n\n--time-cond &quot;$(echo &quot;${url}&quot; | xargs basename)&quot;：仅当远程文件的时间戳更新或本地文件不存在时，才下载文件。$(echo &quot;${url}&quot; | xargs basename) 提取URL中的文件名作为本地文件的名称。\n\nwget\nwget -t 1 -T 1 -w 1 -q -O - &quot;$url&quot;\n\n-t 1：设置最大尝试次数为1次。如果下载失败，wget 不会进行重试。\n-T 1：设置超时时间为1秒。如果下载超过1秒仍未完成，wget 将退出并认为下载失败。\n-w 1：设置每个尝试之间的等待时间为1秒。这样可以在尝试下载之间增加一些延迟，以降低对服务器的负载。\n-q：静默模式，不显示下载进度和其他信息。\n-O -：将下载的内容写入标准输出（stdout）而不是保存到文件中。\n"},"基础技能/vue":{"title":"vue","links":[],"tags":["基础技能"],"content":"安装nodejs\n下载地址 Node.js 中文网 (nodejs.com.cn)\nnodejs安装步骤 Installation · nodejs/help Wiki (github.com)\nlinux安装nodejs参考命令\n[root@ctl01 tmp]# tar -xf node-v18.19.0-linux-x64.tar.xz\n[root@ctl01 tmp]# mv node-v18.19.0-linux-x64 nodejs\n[root@ctl01 tmp]# mv nodejs /usr/local/\n[root@ctl01 tmp]# echo &quot;export PATH=$PATH:/usr/local/nodejs/bin&quot; &gt;&gt; /etc/profile\n[root@ctl01 tmp]# source /etc/profile\n证书过期处理\n# vue创建项目报错\n$ error An unexpected error occurred: &quot;https://registry.npm.taobao.org/@vue%2fcli-plugin-babel: certificate has expired&quot;.\n# 首先更换镜像地址\n$ npm config set registry https://registry.npmmirror.com\n# 调整用户目录下配置\n$ cat .vuerc\n{\n  &quot;useTaobaoRegistry&quot;: false,#如果为true调整为false，如果为false调整为true\n  &quot;packageManager&quot;: &quot;yarn&quot;\n}"},"基础技能/yum":{"title":"yum","links":[],"tags":[],"content":"本地镜像yum源配置\n配置 CentOS 或 RHEL 系统使用 CD-ROM 作为 YUM 源\n\n\n将 CD-ROM 插入到服务器的 CD/DVD 驱动器中。\n\n\n创建一个挂载点，用于挂载 CD-ROM：\n\n\nsudo mkdir /mnt/cdrom\n\n挂载 CD-ROM 到挂载点：\n\nsudo mount /dev/cdrom /mnt/cdrom\n\n进入 /etc/yum.repos.d/ 目录，并备份默认的 YUM 源配置文件：\n\ncd /etc/yum.repos.d/\nsudo mv CentOS-Base.repo CentOS-Base.repo.bak\n\n创建一个新的 YUM 源配置文件：\n\nsudo nano CentOS-CDROM.repo\n\n在编辑器中输入以下内容，并保存文件：\n\n[centos-cdrom]\nname=CentOS-$releasever - CD\nbaseurl=file:///mnt/cdrom\nenabled=1\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7\n\n\n退出编辑器。\n\n\n运行以下命令来清除 YUM 缓存：\n\n\nsudo yum clean all\n\n现在，可以使用 CD-ROM 作为 YUM 源来安装和更新软件包了：\n\nsudo yum install &lt;package-name&gt;"},"基础技能/基础技能":{"title":"基础技能","links":[],"tags":[],"content":"\n\n基础技能\n\n操作系统（如 Linux、Unix、Windows）的基本原理和命令行操作\n网络协议和网络基础知识\n编程基础（如 Python、Shell、Perl）\n\n\n"},"基础技能/服务器raid配置":{"title":"服务器raid配置","links":[],"tags":["基础技能"],"content":"磁盘状态描述\nUGood（Unconfigured Good，未配置正常）：硬盘状态正常，但还未划分给任何逻辑卷\nUBad（Unconfigured Bad，未配置异常）：UGood状态的硬盘出现无法恢复的错误\nOnln（Online，在线）：已经设置为某个虚拟硬盘的成员盘，并且处于在线正常可用状态\nOffln（Offline，离线）：某个虚拟硬盘的成员盘离线\nMissing：Online状态的硬盘脱离RAID组的状态\nRbld（Rebuild，重建）：硬盘正在重建数据\nRaid配置工具\nMegaCli\n基本知识\n$ MegaCli  -PDList  -aALL\nAdapter #0                          #阵列卡号,适配器编号\nEnclosure Device ID: 32             #raid卡的ID号\nSlot Number: 0                      #物理磁盘的slot号,磁盘位置\nStorCli\n基本知识\nc : Controller，控制器，也就是阵列卡\ne : Enclosure，附件，一般来讲也就是硬盘背板“硬盘笼”\ns : Slot，物理硬盘槽位\nv : Virtual Drive，虚拟硬盘，也就是逻辑卷\nd : Disk Group，硬盘组\nf : Foreign configuration file，外部阵列配置\n常用命令\n查看当前的 RAID 配置和状态\nstorcli /c0 show\n创建一个 RAID 1 组，包含两个磁盘（/dev/sda 和 /dev/sdb）\nstorcli /c0 add vd type=raid1 drives=0:0,0:1\nraid6配置示例，将slot0-9配置为raid6\n\n查看新 RAID 组的状态\nstorcli /c0 /v0 show\n查看磁盘状态\nstorcli64 /c0 /eall/sall show\n添加专属热备\n获取空闲磁盘\nstorcli64 /c0 /eall/sall show # 磁盘状态为UGOOD\n添加热备盘\nstorcli64 /cx/ex/sx add hotsparedrive dgs=x\n示例：背板为3，槽位为6的磁盘做 dgs为0的RAID的专属热备\nstorcli64 /c0/e3/s6 add hotsparedrive dgs=0\n删除热备盘\nstorcli /c0/ex/sx delete hotsparedrive\n设置 RAID 组的缓存策略，例如启用写缓存\nstorcli /c0 /v0 set wrcache=enabled\n清除现有的 RAID 组，可以使用以下命令\nstorcli /c0 /v0 delete\n保存配置，以便在重启后保持设置\nstorcli /c0 save"},"基础技能/物理机":{"title":"物理机","links":[],"tags":[],"content":"物理机查看网卡速度\ncat /sys/class/net/*/speed"},"安全和权限管理/iptables":{"title":"iptables","links":[],"tags":["安全和权限管理"],"content":"iptables配置\n添加 iptables 规则\niptables -A INPUT -p tcp -m iprange --src-range 10.191.195.242-10.191.195.245 --dport 2181 -j ACCEPT\niptables -A INPUT -p tcp -m iprange --src-range 10.191.171.45-10.191.171.59 --dport 2181 -j ACCEPT\niptables -A INPUT -p tcp -s 10.191.170.250 --dport 2181 -j ACCEPT\niptables -A INPUT -p tcp --dport 2181 -j DROP\n删除iptables规则\niptables -D INPUT 1 # 删除INPUT链第一条规则\n设置开机自启\n保存当前的 iptables 规则\niptables-save &gt; /etc/sysconfig/iptables\n执行以下命令以将 iptables 设置为开机自启\necho &quot;$(which iptables-restore) &lt; /etc/sysconfig/iptables&quot; &gt;&gt; /etc/init.d/boot.local\nchmod +x /etc/init.d/boot.local\n/etc/init.d/boot.local 脚本中添加一行，以在每次系统启动时恢复 iptables 规则。\n安装配置iptables\n删除firewalld，安装iptables\nsystemctl stop firewalld.service\nsystemctl disable firewalld.service\nyum -y install iptables-services\nsystemctl start iptables.service\nsystemctl enable iptables.service\n修改iptables\n修改配置文件\n配置文件的路径为/etc/sysconfig/iptables，直接编辑文件，例如在该文件最上面的规则插入一条允许80端口的规则\n# sample configuration for iptables service\n# you can edit this manually or use system-config-firewall\n# please do not ask us to add additional ports/services to this default configuration\n*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT\n-A INPUT -p icmp -j ACCEPT\nCOMMIT\n配置立即生效\nsystemctl restart iptables\n命令行配置\n直接在命令行添加了一个允许443端口的规则\niptables -I INPUT -p tcp -m state --state NEW -m tcp --dport 443 -j ACCEPT\n保存规则\nservice iptables save"},"安全和权限管理/ssh":{"title":"ssh","links":[],"tags":["安全和权限管理"],"content":"ssh免密登录\n示例 A为本地主机，BC为远程服务器\n使用ssh-keygen生成密钥对\nssh-keygen\n安装ssh-copy-id命令\nyum install openssh-clients\n拷贝生成的公钥到远程服务器BC，即可在本地主机免密登录远程服务器BC\nssh-copy-id -i ~/.ssh/xxx.pub user@server\n示例\n[root@ctl01 ~]# ssh-copy-id -i .ssh/id_rsa.pub root@10.191.101.128\n/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;.ssh/id_rsa.pub&quot;\nThe authenticity of host &#039;10.191.101.128 (10.191.101.128)&#039; can&#039;t be established.\nECDSA key fingerprint is SHA256:kcGPeZqN7kwKRmmDpg/O3mBazd+psSvHODd8bfUdi6Y.\nECDSA key fingerprint is MD5:e5:b9:be:58:c7:f1:12:bd:66:87:af:94:51:3b:5f:e8.\nAre you sure you want to continue connecting (yes/no)? yes\n/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed\n/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys\nroot@10.191.101.128&#039;s password:\n \nNumber of key(s) added: 1\n \nNow try logging into the machine, with:   &quot;ssh &#039;root@10.191.101.128&#039;&quot;\nand check to make sure that only the key(s) you wanted were added.\n通俗的理解，在ssh免密登录过程中，“我”生成一对钥匙（私钥）和锁（公钥），将锁分发给其他人，需要时用来锁住必要数据，而只有“我”的钥匙能够打开，以此建立安全连接\nssh互信配置\n在三台Linux主机之间配置SSH免密码互信（也称为SSH密钥认证）\n步骤1：生成SSH密钥对\n在每台主机上生成SSH密钥对，如果尚未生成的话。这通常只需要在第一台主机上执行一次，然后将生成的公钥复制到其他主机。然而，为了确保每台主机都可以无密码登录到其他所有主机，需要在每台主机上都生成一对密钥。\n在主机A上执行以下命令：\nssh-keygen -t rsa\n按提示操作，可以选择接受默认的文件位置和不设置密码。这将在~/.ssh/目录下生成id_rsa（私钥）和id_rsa.pub（公钥）文件。\n步骤2：分发公钥\n接下来，将主机A上的公钥复制到其他主机（主机B和C）。可以手动执行，也可以使用ssh-copy-id命令自动完成。\n手动方法：\ncat ~/.ssh/id_rsa.pub | ssh user@hostB &#039;cat &gt;&gt; .ssh/authorized_keys&#039;\ncat ~/.ssh/id_rsa.pub | ssh user@hostC &#039;cat &gt;&gt; .ssh/authorized_keys&#039;\n使用ssh-copy-id命令：\nssh-copy-id user@hostB\nssh-copy-id user@hostC\n步骤3：确保.ssh目录权限正确\n确保每台主机上的.ssh目录和authorized_keys文件的权限正确，以防止未授权访问。\nchmod 700 ~/.ssh\nchmod 600 ~/.ssh/authorized_keys\n步骤4：在所有主机上重复步骤1和步骤2\n让每台主机都能无密码登录到其他主机，需要在每台主机上重复步骤1和步骤2。也就是说，在主机B和C上也要生成SSH密钥对（如果还没有的话），并将它们的公钥复制到其他主机上。\n步骤5：测试免密登录\n在完成配置后，从每台主机尝试登录到其他主机，以验证是否成功配置了免密登录。\nssh user@hostB\nssh user@hostC\n从主机B和C也进行同样的测试。\n注意事项\n\n确保所有主机上的用户名相同，或者在ssh-copy-id命令中使用正确的用户名。\n在生成SSH密钥对时，选择不带密码的选项，以便实现免密码登录。\n如果你正在配置的主机是新系统，你可能需要创建.ssh目录，并确保它有适当的权限，再进行公钥的复制。\n"},"安全和权限管理/公钥与私钥":{"title":"公钥与私钥","links":["安全和权限管理/ssh"],"tags":["安全和权限管理"],"content":"散列算法\n散列算法，也叫做哈希函数，有时候也叫做摘要算法，常用的算法有：MD5 SHA1\nMD5\nMD5 不是一种加密算法，是一种摘要算法，无论多长的输入，MD5 都会输出长度为 128bits 的一个串\nSHA1\nSHA1 算法也是一个摘要算法， SHA1 比 MD5 更加安全，对于长度小于 2^64 位的消息，SHA1 会产生一个 160 位的消息摘要\n摘要算法有摘要特性和不可逆特性，一般用于检查文件的完整性和数据签名的场景\n加密算法\n对称加密\n加、解密使用的是同一串秘钥，只有一个秘钥作为私钥\n常用算法：DES、3DES、Blowfish、IDEA、RC4、RC5、RC6和AES\n非对称加密\n加、解密使用不同秘钥，通常一对私钥与公钥，公钥加密，私钥解密，亦可私钥加密公钥解密），通常加密指代前者，后者叫做“签名”\n常用算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）\nssh\n编码算法\nBase64\n编码算法，将任意二进制编码成文本"},"安全和权限管理/安全和权限管理":{"title":"安全和权限管理","links":[],"tags":[],"content":"\n\n安全和权限管理\n\n系统安全和漏洞管理\n访问控制和权限管理（如 LDAP、RBAC）\n防火墙和网络安全配置\n\n\n"},"应用部署和容灾/应用部署和容灾":{"title":"应用部署和容灾","links":[],"tags":[],"content":"\n\n应用部署和容灾\n\nWeb 服务器和应用服务器的部署和配置（如 Nginx、Apache、Tomcat）\n高可用性和容灾技术（如负载均衡、故障转移、备份恢复）\n\n\n"},"故障排除和性能优化/NTP服务配置":{"title":"NTP服务配置","links":[],"tags":["故障排除和性能优化"],"content":"Network Time Protocol（网络时间协议，NTP）是一种用于在计算机网络中同步时钟的协议。它通过分布式的时间参考源，确保计算设备具有准确和一致的时间。\n安装\n在Linux主机上安装NTP服务。不同的Linux发行版可能有不同的安装方法，但通常可以使用包管理器来安装NTP软件包，例如apt、yum或zypper。\n配置\n在/etc/ntp.conf文件中配置NTP服务器。可以指定一个或多个可靠的NTP服务器作为时间源。可以使用公共的NTP服务器，如pool.ntp.org，或者使用特定的NTP服务器，如公司内部的NTP服务器。\n启动\n启动NTP服务：启动NTP服务以开始同步主机的时钟。在大多数Linux发行版中，可以使用systemctl命令来启动NTP服务\nsudo systemctl start ntpd\n状态\n可以使用ntpq命令或chronyc命令来监控NTP同步状态。这些命令可以显示主机与NTP服务器之间的偏移量和同步状态。\nntpq -p\n偏移\n定期监控时钟偏移是重要的，以确保主机时钟的准确性。可以使用ntpq命令或chronyc命令来查看时钟的偏移量，并确保偏移量在合理的范围内。如果时钟偏移量过大，可能需要检查NTP服务器的配置或网络连接，以解决同步问题。"},"故障排除和性能优化/linux-出错-task-xxxxx-634-blocked-for-more-than-120-seconds":{"title":"linux 出错 task xxxxx 634 blocked for more than 120 seconds","links":[],"tags":["故障排除和性能优化"],"content":"问题现象\n\n系统挂起，无法响应\nSSH无响应，但可以ping通\n报错关键信息包含 hung_task_timeout_secs\n\n原因分析\nlinux kernel bug相关资料显示\nBy default Linux uses up to 40% of the available memory for file system caching.\nAfter this mark has been reached the file system flushes all outstanding data to disk causing all following IOs going synchronous.\nFor flushing out this data to disk this there is a time limit of 120 seconds by default.\nIn the case here the IO subsystem is not fast enough to flush the data withing 120 seconds.\nThis especially happens on systems with a lot of memory.\nThe problem is solved in later kernels\n一般情况下，linux会把可用内存的40%的空间作为文件系统的缓存。当缓存快满时，文件系统将缓存中的数据整体同步到磁盘中。但是系统对同步时间有最大120秒的限制。如果文件系统不能在时间限制之内完成数据同步，则会发生上述的错误。这通常发生在内存很大的系统上。系统内存大，则缓冲区大，同步数据所需要的时间就越长，超时的概率就越大\n解决方案\n缩小文件系统缓存大小\n降低缓存占内存的比例，比如由40%降到10%，则需要同步到磁盘上的数据量会变小，IO写时间缩短，会相对比较平稳。文件系统缓存的大小是由内核参数vm.dirty_ratio 和 vm.dirty_backgroud_ratio控制决定的\nvm.dirty_background_ratio 指定当文件系统缓存脏页数量达到系统内存百分之多少时（如5%）就会触发pdflush/flush/kdmflush等后台回写进程运行，将一定缓存的脏页异步地刷入外存\nvm.dirty_ratio 则指定了当文件系统缓存脏页数量达到系统内存百分之多少时（如10%），系统不得不开始处理缓存脏页（因为此时脏页数量已经比较多，为了避免数据丢失需要将一定脏页刷入外存），在此过程中很多应用进程可能会因为系统转而处理文件IO而阻塞\n通常情况下，vm.dirty_ratio的值要大于vm.dirty_background_ratio的值\nsysctl -a | grep dirty\n修改（降低）vm.dirty_ratio和vm.dirty_ background_ratio的值\n./sbin/sysctl -w vm.dirty_ratio=10\n./sbin/sysctl -w vm.dirty_background_ratio=5\n参数生效\nsysctl -p\n修改系统IO调度策略\nLinux的IO共有三种调度器：CFQ、Noop、Deadline\nCFQ （Completely Fair Scheduler（完全公平调度器））（cfq）：它是许多Linux 发行版的默认调度器；它将由进程提交的同步请求放到多个进程队列中，然后为每个队列分配时间片以访问磁盘\nNoop调度器（noop）：基于先入先出（FIFO）队列概念的Linux内核里最简单的I/O调度器。此调度程序最适合于SSD\n截止时间调度器（deadline）：尝试保证请求的开始服务时间\nLinux发行版的默认采用的是CFQ调度器。此方案就是把CFQ调度器修改为最简单的Noop调度器\n查看当前采用的调度器\ncat /sys/block/sda/queue/scheduler\n修改调度器，调度器的修改立即生效，不必重启内核\necho noop &gt;/sys/block/sda/queue/scheduler\n取消120秒时间限制\n内核hung task检测机制：进程等待IO时，经常处于D状态（TASK_UNINTERRUPTIBLE），该状态的进程不处理信号，所以kill不掉，如果进程长期处于D状态则不正常\n\nIO路径硬件问题，如硬盘损坏（少数情况会导致长期D，通常会返回错误）\n内核问题\n\n这类问题不好定位，且出现通常不可恢复，kill不掉，一般只能重启恢复\n内核针对此种情况开发了一种hung task的检测机制，基本原理是：定时检测系统中处于D状态的进程，如果其处于D状态的时间超过了指定时间（默认120s，可配置），则打印相关堆栈信息，也可以通过proc参数配置使其直接panic\n120秒的时间限值由内存参数kernel.hung_task_timeout_secs决定的，如果值设置为0，就是设置为长整型的最大值\n查看当前hung_task_timeout_secs值\nsysctl -a | grep hung_task_timeout_secs\n修改hung_task_timeout_secs值为0\n./sbin/sysctl -w kernel.hung_task_timeout_secs=0\n参数生效\nsysctl  -p\n永久修改内核参数\n在上述方案中采用sysctl修改内核参数重启后失效，永久修改配置文件/etc/sysctl.conf\nvm.dirty_ratio=10\nvm.dirty_background_ratio=5\n如果系统没有sysctl.conf文件，则可以自己创建sysctl.conf，如果开机启动时系统没有读取sysctl.conf文件进行配置，通过修改启动文件来解决，部分linux启动文件是/etc/init.d/rcS，在末尾添加./sbin/sysctl -p"},"故障排除和性能优化/mysql":{"title":"mysql","links":[],"tags":["故障排除和性能优化"],"content":"数据库断电无法重启\n报错内容\n[root@ctl01 ~]# more /var/log/mariadb/mariadb.log\n2024-03-13 11:23:59 0 [Note] InnoDB: Using Linux native AIO\n2024-03-13 11:23:59 0 [Note] InnoDB: Mutexes and rw_locks use GCC atomic builtins\n2024-03-13 11:23:59 0 [Note] InnoDB: Uses event mutexes\n2024-03-13 11:23:59 0 [Note] InnoDB: Compressed tables use zlib 1.2.7\n2024-03-13 11:23:59 0 [Note] InnoDB: Number of pools: 1\n2024-03-13 11:23:59 0 [Note] InnoDB: Using SSE2 crc32 instructions\n2024-03-13 11:23:59 0 [Note] InnoDB: Initializing buffer pool, total size = 128M, instances = 1, chunk size = 128M\n2024-03-13 11:23:59 0 [Note] InnoDB: Completed initialization of buffer pool\n2024-03-13 11:24:00 0 [Note] InnoDB: If the mysqld execution user is authorized, page cleaner thread priority can be changed. See the man page of\n setpriority().\n2024-03-13 11:24:00 0 [ERROR] InnoDB: Missing MLOG_CHECKPOINT at 135649212 between the checkpoint 135649212 and the end 135648768.\n2024-03-13 11:24:00 0 [ERROR] InnoDB: Plugin initialization aborted with error Generic error\n2024-03-13 11:24:00 0 [Note] InnoDB: Starting shutdown...\n2024-03-13 11:24:00 0 [ERROR] Plugin &#039;InnoDB&#039; init function returned error.\n2024-03-13 11:24:00 0 [ERROR] Plugin &#039;InnoDB&#039; registration as a STORAGE ENGINE failed.\n2024-03-13 11:24:00 0 [Note] Plugin &#039;FEEDBACK&#039; is disabled.\n2024-03-13 11:24:00 0 [ERROR] Unknown/unsupported storage engine: innodb\n2024-03-13 11:24:00 0 [ERROR] Aborting\n问题解决，尝试以下几点：\n\n在主从上设置innodb_log_checksums = ON\n删除rm /var/lib/mysql/ib_logfile*\n重新启动\n"},"故障排除和性能优化/openstack虚拟机挂载iso":{"title":"openstack虚拟机挂载iso","links":[],"tags":["故障排除和性能优化"],"content":"列出所有虚拟机\nvirsh list --all\n关闭虚拟机\nvirsh  destroy  guest-rhel7\n编辑虚拟机文件\nvirsh  edit  guest-rhel7\n添加cdrom镜像\n &lt;disk type=&#039;file&#039; device=&#039;cdrom&#039;&gt;\n      &lt;driver name=&#039;qemu&#039; type=&#039;raw&#039;/&gt;\n      &lt;source file=&#039;/kvm/iso/CentOS-7-x86_64-DVD-2009.iso&#039;/&gt;\n      &lt;target dev=&#039;hda&#039; bus=&#039;ide&#039;/&gt;\n      &lt;readonly/&gt;\n      &lt;address type=&#039;drive&#039; controller=&#039;0&#039; bus=&#039;0&#039; target=&#039;0&#039; unit=&#039;0&#039;/&gt;\n&lt;/disk&gt;\n将boot 改为光盘启动\n &lt;os&gt;\n    &lt;type arch=&#039;x86_64&#039; machine=&#039;pc-i440fx-rhel7.0.0&#039;&gt;hvm&lt;/type&gt;\n    &lt;boot dev=&#039;cdrom&#039;/&gt;\n    &lt;bootmenu enable=&#039;yes&#039;/&gt;\n&lt;/os&gt;\n检查虚拟机配置\nvirsh domblklist guest-rhel7\n开启虚拟机\nvirsh  start guest-rhel7\n注意：由于openstack nova-compute服务对虚拟机电源状态同步会自动关机，因此可以采用：\n临时停止宿主机nova-compute\nsystemctl stop openstack-nova-compute.service\n查看vnc端口\n通过vnc工具连接该宿主机IP和以下对应端口进入虚拟机控制台\nvirsh  vncdisplay guest-rhel7\n:0"},"故障排除和性能优化/故障排除和性能优化":{"title":"故障排除和性能优化","links":[],"tags":[],"content":"\n\n故障排除和性能优化\n\n系统故障排查和调优\n性能监测和性能优化技术\n容量规划和资源管理\n\n\n"},"故障排除和性能优化/鸿蒙OS系统优化":{"title":"鸿蒙OS系统优化","links":[],"tags":["故障排除和性能优化"],"content":"使用ADB工具，将手机开启调试模式，卸载或禁用系统应用和组件，提升手机运行效率\n执行前注意：请务必关闭系统“纯净模式”\n前置条件\n1、进入设置 → 关于手机，连击 5 次版本号，打开开发者模式\n2、进入设置 → 系统和更新 → 开发人员选项，勾选USB 调试和“仅充电”模式下允许 ADB 调试\n3、连接手机，选择仅充电，弹出提示框后，勾选允许该电脑通过 USB 调试设备并点击允许按钮\n4、打开设置 → 系统和更新 → 纯净模式，选择“退出”并确认，进而关闭“纯净模式”，否则之后会无法安装软件\n预置应用\n./adb.exe shell pm uninstall --user 0 com.baidu.searchbox # &quot;百度&quot;App\n./adb.exe shell pm uninstall --user 0 com.UCMobile # &quot;UC浏览器&quot;App\n./adb.exe shell pm uninstall --user 0 com.suning.mobile.ebuy # &quot;苏宁易购&quot;App\n./adb.exe shell pm uninstall --user 0 com.netease.newsreader.activity # &quot;网易新闻&quot;App\n./adb.exe shell pm uninstall --user 0 com.sina.weibo # &quot;新浪微博&quot;App\n./adb.exe shell pm uninstall --user 0 com.sankuai.meituan # &quot;美团&quot;App\n./adb.exe shell pm uninstall --user 0 com.dianping.v1 # &quot;大众点评&quot;App\n./adb.exe shell pm uninstall --user 0 com.jingdong.app.mall # &quot;京东&quot;App\n./adb.exe shell pm uninstall --user 0 com.ss.android.article.news # &quot;今日头条&quot;App\n./adb.exe shell pm uninstall --user 0 com.ss.android.ugc.aweme # &quot;抖音&quot;App\n./adb.exe shell pm uninstall --user 0 com.taobao.taobao # &quot;淘宝&quot;App\n./adb.exe shell pm uninstall --user 0 cn.TuHu.android # &quot;途虎养车&quot;App\n./adb.exe shell pm uninstall --user 0 ctrip.android.view # &quot;携程旅行&quot;App\n./adb.exe shell pm uninstall --user 0 com.ximalaya.ting.android  # &quot;喜马拉雅&quot;App\n./adb.exe shell pm uninstall --user 0 com.achievo.vipshop # &quot;唯品会&quot;App\n./adb.exe shell pm uninstall --user 0 cn.wps.moffice_eng # &quot;WPS Office&quot;App\n./adb.exe shell pm uninstall --user 0 com.booking # &quot;Booking.com 缤客&quot;App\n./adb.exe shell pm uninstall --user 0 com.eg.android.AlipayGphone # &quot;支付宝&quot;App\n系统应用\n推荐卸载\n./adb.exe shell pm uninstall --user 0 com.huawei.hifolder # 卸载竞品推荐,纯广告,卸载!!!\n./adb.exe shell pm uninstall --user 0 com.huawei.educenter # &quot;教育中心&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.hiskytone # &quot;天际通&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.skytone # &quot;天际通&quot;服务\n./adb.exe shell pm uninstall --user 0 com.huawei.gamebox # &quot;游戏中心&quot;App,不玩游戏可删!\n./adb.exe shell pm uninstall --user 0 com.huawei.game.kitserver  # &quot;GameKit&quot;服务,不玩游戏可删!\n./adb.exe shell pm uninstall --user 0 com.huawei.gameassistant # &quot;应用助手&quot;服务,其实就是&quot;游戏助手,不玩游戏可删!\n./adb.exe shell pm uninstall --user 0 com.huawei.tips # &quot;智能提醒&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.android.tips # &quot;玩机技巧&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.health  # &quot;运动健康&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.ohos.health # [HarmongOS]&quot;运动健康&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.stylus.mpenzone # &quot;手写笔应用专区&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.stylus.floatmenu # &quot;手写笔悬浮窗&quot;服务\n./adb.exe shell pm uninstall --user 0 com.huawei.wallet  # &quot;华为钱包&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.wallet.sdk.walletsdk # &quot;WalletSDK&quot;服务,钱包 SDK 而已\n./adb.exe shell pm uninstall --user 0 com.unionpay.tsmservice # &quot;银联可信服务安全组件&quot;,给华为钱包调用的安全组件\n./adb.exe shell pm uninstall --user 0 com.hicloud.android.clone  # &quot;手机克隆&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.mirror  # &quot;镜子&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.android.remotecontroller # &quot;智能遥控&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.ar.measure  # &quot;AR 测量&quot;\n./adb.exe shell pm uninstall --user 0 com.android.soundrecorder  # &quot;录音机&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.email # &quot;电子邮件&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.mycenter # &quot;会员中心&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.lives # &quot;生活服务&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.smarthome # &quot;智慧生活&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.ohos.smarthome  # [HarmongOS]&quot;智慧生活&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.hilink.framework # &quot;智慧生活基础服务&quot;\n./adb.exe shell pm uninstall --user 0 com.vmall.client # &quot;华为商城&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.hwireader # &quot;阅读&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.welinknow # &quot;Link Now&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.compass # &quot;指南针&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.intelligent # &quot;智慧助手·今天&quot;服务,负一屏的垃圾广告\n./adb.exe shell pm uninstall --user 0 com.huawei.magazine # &quot;杂志锁屏&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.hwdetectrepair  # &quot;智能检测&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.phoneservice # &quot;我的华为&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.hwblockchain # &quot;华为区块链&quot;????,这... ...删了吧!\n./adb.exe shell pm uninstall --user 0 com.huawei.search  # &quot;智慧搜索&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.searchservice  # &quot;融合搜索服务&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.ohos.search # [HarmongOS]&quot;全局搜索数据服务&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.meetime # &quot;畅连&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.hwvoipservice # &quot;畅连服务&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.android.findmyphone # &quot;查找设备&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.videoeditor # &quot;视频编辑&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.himovie # &quot;华为视频&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.himovie.partner1\n./adb.exe shell pm uninstall --user 0 com.huawei.himovie.partner2\n./adb.exe shell pm uninstall --user 0 com.tencent.qqlivehuawei # &quot;华为视频&quot;App - 腾讯视频模块\n./adb.exe shell pm uninstall --user 0 com.sohu.sohuvideo.emplayer # &quot;华为视频&quot;App - 搜狐视频模块\n./adb.exe shell pm uninstall --user 0 com.android.mediacenter # &quot;华为音乐&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.scenepack # &quot;旅行助手&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.hicard  # &quot;HiCard&quot;卡片服务\n./adb.exe shell pm uninstall --user 0 com.huawei.hicar # &quot;HiCar&quot;汽车服务\n./adb.exe shell pm uninstall --user 0 com.huawei.android.karaoke # &quot;K 歌特效&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.featurelayer.sharedfeature.xrkit # &quot;XRKit&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.arengine.service # &quot;AREngineServer&quot;华为 AR 引擎服务\n./adb.exe shell pm uninstall --user 0 com.huawei.audioaccessorymanager # &quot;音频产品管家&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.waudio  # &quot;WAudios&quot;,不知是啥!\n./adb.exe shell pm uninstall --user 0 com.huawei.multimedia.audioengine  # &quot;HwAudioKit&quot;,不知是啥!\n./adb.exe shell pm uninstall --user 0 com.android.simappdialog #  &quot;SIM App Dialog&quot;\n./adb.exe shell pm uninstall --user 0 com.android.stk  # &quot;SIM 卡应用&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.android.thememanager # &quot;主题&quot;App,更换完主题就删除,用的时候在&quot;华为应用商店&quot;安装就行了;\n./adb.exe shell pm uninstall --user 0 com.huawei.hidisk  # &quot;华为云空间&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.hicloud # &quot;华为云空间服务&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.privatespace # &quot;隐私空间&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.securitymgr # &quot;隐私空间&quot;\n./adb.exe shell pm uninstall --user 0 com.android.providers.calendar # &quot;日历存储&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.ohos.suggestion # &quot;小艺建议&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.pengine # &quot;华为智能建议&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.spaceservice # 华为&quot;地理围栏服务&quot;,其实就是精准推送广告\n./adb.exe shell pm uninstall --user 0 com.huawei.fastapp # 华为&quot;快应用中心&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.localBackup # 华为&quot;备份&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.easygo # 华为&quot;EasyGo SDK&quot;,给折叠屏用的;\n./adb.exe shell pm uninstall --user 0 com.huawei.trustspace  # 华为&quot;支付保护中心&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.featurelayer.sharedfeature.map  # &quot;华为地图服务&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.featurelayer.featureframework # &quot;Feature Framework&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.hiai # &quot;华为智慧引擎&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.hiaction # 华为&quot;HUAWEI HiAI Base&quot; 基础服务\n./adb.exe shell pm uninstall --user 0 com.huawei.recsys # &quot;华为智慧引擎&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.vassistant  # 华为&quot;智慧语音&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.contactscamcard # &quot;扫名片&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.hitouch # 华为&quot;智慧识屏&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.vrservice # &quot;华为 VR 服务&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.motionservice # 华为&quot;手势服务&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.devicemanager # 华为&quot;智慧协同&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.android.airsharing  # 华为&quot;无线投屏&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.suggestion  # 华为&quot;情景智能&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.scanner # 华为&quot;智慧视觉&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.pcassistant # &quot;华为分享&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.android.instantshare # &quot;华为分享&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.android.wfdft # &quot;WLAN 直连&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.android.FloatTasks # 华为&quot;悬浮导航&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.printservice  # &quot;华为打印&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.nearby  # 华为&quot;HwNearby&quot;附近服务\n./adb.exe shell pm uninstall --user 0 com.bjbyhd.screenreader_huawei # 华为&quot;屏幕朗读&quot;服务\n./adb.exe shell pm uninstall --user 0 com.huawei.desktop.explorer # 华为&quot;我的文件&quot;\n./adb.exe shell pm uninstall --user 0 com.android.providers.downloads # &quot;下载管理&quot;\n./adb.exe shell pm uninstall --user 0 com.android.providers.downloads.ui  # &quot;下载管理&quot; UI\n./adb.exe shell pm uninstall --user 0 com.huawei.assetsync # 华为&quot;关键资产同步&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.assetsyncservice # 华为&quot;关键资产同步&quot;服务\n./adb.exe shell pm uninstall --user 0 com.huawei.contacts.sync # 华为&quot;联系人同步&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.airlink # 华为&quot;Air Link&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.rcsserviceapplication # &quot;华为 RCS 服务&quot;,同华为手机的免费短信\n./adb.exe shell pm uninstall --user 0 com.huawei.bluetooth # 华为&quot;通过蓝牙导入&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.trustagent  # 华为&quot;智能解锁&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.hwbluetoothpencilmanager # 华为&quot;蓝牙触控笔管理&quot;\n./adb.exe shell pm uninstall --user 0 com.iflytek.speechsuite # 讯飞语音引擎\n./adb.exe shell pm uninstall --user 0 com.huawei.ohos.famanager # [HarmongOS]华为&quot;服务中心&quot;\n./adb.exe shell pm uninstall --user 0 com.android.sharedstoragebackup # &quot;共享存储备份&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.hwpanpayservice # 华为&quot;息屏支付&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.hwdiagnosis # 华为&quot;检测/诊断&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.controlcenter # 华为&quot;超级终端&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.multimedia.hivideoplayengine # 华为&quot;视频开发引擎&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.regservice  # 华为&quot;注册服务&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.trustedthingsauth # 华为&quot;可信认证跳过&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.synergy # 华为&quot;协同&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.coauthservice # 华为&quot;联合认证&quot;\n谨慎考虑\n./adb.exe shell pm uninstall --user 0 com.huawei.calculator  # &quot;计算器&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.android.totemweather # &quot;天气&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.notepad # &quot;备忘录&quot;App\n./adb.exe shell pm uninstall --user 0 com.huawei.browser # 华为&quot;浏览器&quot;App,推荐 Edge 浏览器,别用&quot;夸克&quot;了,太&quot;和谐&quot;了!\n./adb.exe shell pm uninstall --user 0 com.huawei.calendar # 华为&quot;日历&quot;App\n./adb.exe shell pm uninstall --user 0 com.android.deskclock  # 华为&quot;时钟&quot;App\n./adb.exe shell pm uninstall --user 0 com.baidu.input_huawei # &quot;百度输入法&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.securityserver  # &quot;华为安全公共服务&quot;\n./adb.exe shell pm uninstall --user 0 com.huawei.filemanager # 华为&quot;文件管理&quot;,推荐 &quot;MT管理器&quot;\n动画和帧数优化\n./adb.exe shell settings put global window_animation_scale 0.96\n./adb.exe shell settings put global transition_animation_scale 0.96\n./adb.exe shell settings put global animator_duration_scale 0.43\n./adb.exe shell wm density 480"},"文档和沟通能力/文档和沟通能力":{"title":"文档和沟通能力","links":[],"tags":[],"content":"\n\n文档和沟通能力\n\n技术文档编写和维护\n团队协作和沟通能力\n问题解决和故障处理技巧\n\n\n"},"监控和日志管理/监控和日志管理":{"title":"监控和日志管理","links":[],"tags":[],"content":"\n\n监控和日志管理\n\n监控系统的搭建和配置（如 Zabbix、Prometheus）\n日志管理和分析工具（如 ELK Stack、Splunk）\n\n\n"},"网络和存储管理/ceph":{"title":"ceph","links":[],"tags":["网络和存储管理"],"content":"osd down 处理\n检查集群状态\nceph -s\n\n查看osd tree\nceph osd tree | more\n\n恢复osd\n登录对应节点，重启osd\nservice ceph status osd.77\nservice ceph restart osd.77\n\n检查osd up\nceph osd tree | more\n查看ceph osd\nps -aux|grep ceph-osd\n\nps -ef|grep ceph-osd\n\n数据recovery流量控制\n本质上，用户数据写入ceph时，会被切分成大小相等的object，这些object由PG承载，分布到不同的OSD上（每个OSD一般会对应一块硬盘）。数据的迁移会以PG为单位进行，所以当PG发生变化时，就会有数据rebalance。\n后端的数据均衡IO会对client的IO造成影响从而影响到集群的业务IO，所以我们需要对数据均衡IO进行控制，主要是业务优先和恢复优先。\n业务优先\nceph tell osd.* injectargs &#039;--osd-max-backfills 1 --osd-recovery-max-active 1 --osd-recovery-max-single-start 1&#039;\nceph tell osd.* injectargs &#039;--osd-recovery-sleep 1&#039;\n恢复优先\nceph tell osd.* injectargs &#039;--osd-max-backfills 5 --osd-recovery-max-active 5 --osd-recovery-max-single-start 5&#039;\nceph tell osd.* injectargs &#039;--osd-recovery-sleep 0&#039;\n在业务繁忙时，完全关闭数据重建及迁移：\nceph osd set norebalance\nceph osd set norecover\nceph osd set nobackfill\n在业务空闲时，打开数据重建及迁移\nceph osd unset norebalance\nceph osd unset norecover\nceph osd unset nobackfill\n如果想长期有效，可以在进行以上操作立即生效后，修改所有ceph集群节点的配置文件。\n注：查看现有recovery配置信息，这里的133为具体osd的id号\nceph --admin-daemon  /var/run/ceph/ceph-osd.133.asok config show | grep -E &quot;osd_max_backfills|osd_recovery_max_active|osd_recovery_max_single_start|osd_recovery_sleep&quot;\n    &quot;osd_max_backfills&quot;: &quot;1&quot;,\n    &quot;osd_recovery_max_active&quot;: &quot;1&quot;,\n    &quot;osd_recovery_max_single_start&quot;: &quot;1&quot;,\n    &quot;osd_recovery_sleep&quot;: &quot;0.000000&quot;,\n    &quot;osd_recovery_sleep_hdd&quot;: &quot;0.100000&quot;,\n    &quot;osd_recovery_sleep_hybrid&quot;: &quot;0.025000&quot;,\n    &quot;osd_recovery_sleep_ssd&quot;: &quot;0.000000&quot;,"},"网络和存储管理/keepalived":{"title":"keepalived","links":[],"tags":["网络和存储管理"],"content":"Keepalived是一个用于实现高可用性和负载均衡的软件，常用于配置主备服务器或虚拟 IP 地址的故障切换\n常规配置\nglobal_defs\nglobal_defs包含全局定义的配置项\nrouter_id：定义 Keepalived 实例的唯一标识符\nnotification_email：定义在故障切换或状态变化时接收通知的电子邮件地址\nnotification_email_from：定义发送通知的电子邮件地址\nsmtp_server：指定用于发送电子邮件通知的 SMTP 服务器的地址\nsmtp_connect_timeout：定义连接到 SMTP 服务器的超时时间\nrouter_id 和 notification_email 是全局定义的必需配置项，而其他配置项是可选的，根据需要进行配置\nvrrp_instance\nvrrp_instance定义一个 VRRP（Virtual Router Redundancy Protocol）实例，用于配置主备服务器或虚拟 IP 地址的故障切换\nstate：指定服务器的状态，可以是 MASTER、BACKUP 或 FAULT\ninterface：指定用于 VRRP 实例的网络接口\nvirtual_router_id：定义 VRRP 路由器的唯一标识符\npriority：指定服务器的优先级，用于选举 MASTER 服务器\nadvert_int：定义 VRRP 广告间隔，即发送 VRRP 通告的时间间隔\nauthentication：指定 VRRP 通信的认证密码\nvirtual_ipaddress：定义虚拟 IP 地址，当服务器处于 MASTER 状态时，该地址将被分配给服务器\nvirtual_server\nvirtual_server用于配置负载均衡的虚拟服务器\ndelay_loop：定义检查服务器健康状态的时间间隔\nlb_algo：定义负载均衡算法，例如 rr（轮询）或 wrr（加权轮询）\nlb_kind：定义负载均衡类型，例如 NAT（网络地址转换）或 DR（直接路由）\nreal_server：定义真实服务器的 IP 地址和端口\n配置示例\n配置主服务器（MASTER）和备份服务器（BACKUP）的 Keepalived 实例，当主服务器无法正常工作时，备份服务器将接管虚拟 IP 地址并成为活动服务器\nMaster（主服务器）配置文件\n! 全局定义\nglobal_defs {\n    router_id keepalived_example\n}\n\n! VRRP 实例 - 主服务器\nvrrp_instance VI_1 {\n    state MASTER\n    interface ens3\n    virtual_router_id 51\n    priority 100\n    advert_int 1\n    authentication {\n        auth_type PASS\n        auth_pass example_password\n    }\n    virtual_ipaddress {\n        10.191.18.211\n    }\n}\n\nSlave（备份服务器）配置文件\n! 全局定义\nglobal_defs {\n    router_id keepalived_example\n}\n\n! VRRP 实例 - 备份服务器\nvrrp_instance VI_1 {\n    state BACKUP\n    interface ens3\n    virtual_router_id 51\n    priority 90\n    advert_int 1\n    authentication {\n        auth_type PASS\n        auth_pass example_password\n    }\n    virtual_ipaddress {\n        10.191.18.211\n    }\n}\n\n在主服务器的配置文件中，state 设置为 MASTER，priority 设置为较高的值（例如100），表示它是主服务器，并具有更高的优先级\n在备份服务器的配置文件中，state 设置为 BACKUP，priority 设置为较低的值（例如90），表示它是备份服务器，并具有较低的优先级"},"网络和存储管理/mysql":{"title":"mysql","links":[],"tags":["网络和存储管理"],"content":""},"网络和存储管理/pgsql":{"title":"pgsql","links":[],"tags":["网络和存储管理"],"content":""},"网络和存储管理/网络和存储管理":{"title":"网络和存储管理","links":[],"tags":[],"content":"\n\n网络和存储管理\n\n网络设备的配置和管理\n存储管理和数据备份策略\n数据库管理（如 MySQL、PostgreSQL、MongoDB）\n\n\n"},"自动化和编程/Jinja2":{"title":"jinja2","links":[],"tags":["自动化和编程"],"content":"特点\n\n\n语法简洁：Jinja2使用简洁而易读的语法，使用大括号{{ }}表示变量插值，使用{% %}表示控制流语句（如条件和循环），以及使用{# #}表示注释\n\n\n变量插值：Jinja2允许在模板中插入变量的值。可以将变量直接插入到模板中，或者使用过滤器对变量进行处理和格式化\n\n\n控制流语句：Jinja2支持条件语句（如if、else、elif）和循环语句（如for、while）。这些语句允许根据条件或迭代集合来控制模板的输出\n\n\n模板继承：Jinja2支持模板继承，可以定义一个基础模板（父模板），然后在派生模板（子模板）中根据需要重写和扩展父模板的内容\n\n\n过滤器和函数：Jinja2提供了多个内置过滤器和函数，用于对变量进行处理和转换。可以使用这些过滤器和函数对变量进行格式化、截取、排序等操作\n\n\n宏（Macro）：宏是一种用于定义可重用代码块的机制。可以使用宏来定义一段代码，并在模板的其他地方多次调用该代码块\n\n\n自定义扩展：Jinja2允许开发者自定义扩展，以增加额外的功能和语法。可以编写自定义过滤器、函数、测试等，以满足特定的需求\n\n\n短横线\n在Jinja2模板语言中，花括号 { 和 } 用来包裹模板标签，而短横线 - 在某些情况下用于移除生成的HTML或文本输出中的空白字符，包括换行和空格。在循环 {% for ... %} 结构中，前后添加 -（即 {%- %} 或 % -}）是为了避免在生成的输出中产生不必要的空白。\n具体来说，{%- for ip in ctl_ips -%} 这样的写法意在：\n\n移除循环开始之前的空白：确保循环开始前的任何潜在空白不会出现在生成的输出中。\n移除循环结束之后的空白：确保循环结束后不会留下额外的空白。\n\n这在生成HTML或配置文件时尤为重要，因为不必要的空白可能会导致格式问题，尤其是在需要严格格式化的场景中，比如XML或YAML文件。\n例如，假设有一个简单的循环，用于生成一系列逗号分隔的IP地址：\n{%- for ip in ctl_ips -%}\n{{ ip }},\n{%- endfor -%}\n如果没有使用短横线，每次循环结束时可能会生成额外的换行和空格，导致输出如：\n192.168.1.1,\n \n192.168.1.2,\n \n192.168.1.3,\n\n而使用短横线 {%- for ... -%} 和 {%- endfor -%} 后，输出将是连续的，没有额外的空白：\n192.168.1.1,192.168.1.2,192.168.1.3,\n\n当然，可能还需要考虑循环结束后的逗号是否多余，这取决于的具体需求。"},"自动化和编程/ansible":{"title":"ansible","links":["自动化和编程/jinja2"],"tags":["自动化和编程"],"content":"简介\n基于Python开源的自动化工具，用于配置管理、部署、编排和远程执行任务，它使用SSH协议进行通信，由Paramiko（Python库）、 PyYAML和Jinja2 ( 模板化 ) 三个关键模块实现，并使用基于YAML的描述文件来定义任务和配置\n特性\n\n模块化\n无客户端\n主从模式\n幂等性\n\n关键参数\n\n\n主机清单（Inventory）：主机清单是一个YAML或INI格式的文件，用于定义受管理的主机和主机组，它指定了Ansible将在哪些主机上执行任务\n\n\n模块（Module）：模块是Ansible的基本执行单元，用于在目标主机上执行特定的任务，Ansible提供了丰富的模块库，包括文件操作、软件包管理、用户管理等各种功能\n\n\nPlaybook（剧本）：Playbook是一个YAML格式的文件，用于定义一系列任务和配置的顺序，它描述了Ansible在目标主机上执行的操作流程，包括主机选择、任务执行和变量设置等\n\n\n角色（Role）：角色是一种组织和复用任务和配置的方法，它将相关的任务、变量和文件组织在一起，以便在多个Playbook中重复使用\n\n\n变量（Variable）：变量用于存储和传递数据，在Playbook中可以使用变量来实现灵活的配置，变量可以在主机清单、Playbook和角色中定义，并可以通过模板或命令行参数进行动态设置\n\n\nHandlers：Handlers是一种特殊的任务，它用于响应其他任务的状态变化，当某个任务发生变化时，Handlers可以触发相应的操作，如重新启动服务、重新加载配置等\n\n\n模板（Template）：模板是一种用于生成配置文件的机制，Ansible使用jinja2模板引擎，可以在模板中使用变量和条件语句来动态生成配置文件\n\n\nVault：Vault用于安全地存储敏感信息，如密码和密钥，它可以加密和解密Ansible的变量文件，以防止敏感信息泄露\n\n\n开始\n[root@localhost ~]# ansible localhost -m command -a &#039;echo hello world!&#039;\nlocalhost | CHANGED | rc=0 &gt;&gt;\nhello world!\nAd-Hoc\n简短地指令，指令操作模式\n[root@localhost ansible]# ansible local -m ping\n10.191.101.254 | SUCCESS =&gt; {\n    &quot;ansible_facts&quot;: {\n        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;\n    },\n    &quot;changed&quot;: false,\n    &quot;ping&quot;: &quot;pong&quot;\n}\nAd-Hoc commands 一次只能处理一件事情，这即是它与 Playbooks 最大的差异\nPlaybook\nAnsible 剧本，可以通过事先写好的剧本 (Playbooks)来让各个被控节点进行指定的动作 (Plays) 和任务 (Tasks)\n[root@localhost ansible]# ansible-playbook playbooks/main.yml\n\nPLAY [Test] *************************************************************************************************************************************\n\nTASK [Gathering Facts] **************************************************************************************************************************\nok: [10.191.101.254]\n\nTASK [Hello world] ******************************************************************************************************************************\nchanged: [10.191.101.254]\n\nTASK [Print stdout] *****************************************************************************************************************************\nok: [10.191.101.254] =&gt; {\n    &quot;msg&quot;: &quot;&quot;\n}\n\nPLAY RECAP **************************************************************************************************************************************\n10.191.101.254             : ok=3    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\n\nPlay、Task与Module\n\nPlay：通常为某个特定的目的，例如：\n\nSetup a official website with Drupal (借由 Drupal 建置官网)\nRestart the API service (重开 API 服务)\n\n\nTask：是要实行 Play 这个目地所需做的每个步骤，例如：\n\nInstall the Nginx (安裝 Nginx)\nKill the djnago process (强制停止 django 的行程)\n\n\nModule：Ansible 所提供的各种操作方法，例如：\n\napt: name=vim state=present (使用 apt 套件安装 vim)\ncommand: /sbin/shutdown -r now (使用 shutdown 的指令重新开机)\n\n\n\nAnsible inventory\n用于动态生成Ansible inventory的命令行工具，Ansible inventory用于定义Ansible可以管理的主机和主机组，以及与这些主机相关的变量，通过使用ansible-inventory命令，可以根据不同的数据源生成动态的Ansible inventory\n\n查看当前主机和主机组\n\nansible-inventory --list\n\n使用静态文件生成inventory，使用静态的INI格式文件来定义主机和主机组\n\n[web_servers]\nweb1 ansible_host=192.168.1.10\nweb2 ansible_host=192.168.1.11\n \n[db_servers]\ndb1 ansible_host=192.168.1.20\ndb2 ansible_host=192.168.1.21\n\n使用动态脚本来生成更灵活的inventory，创建一个Python脚本，并实现必要的逻辑来动态生成inventory\n\nansible-inventory -i dynamic_inventory.py --list\n\n使用外部数据源生成inventory，ansible-inventory可以与外部数据源集成，如AWS EC2、OpenStack，使用相关插件来配置和指定数据源\n\nansible-inventory -i ec2.yaml --list\nansible hosts\n/etc/ansible/hosts 是主机清单配置文件，由 ansible.cfg文件中的 inventory 变量配置，默认值为/etc/ansible/hosts，在使用ansible命令前，需要对hosts文件进行相关主机清单配置\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n参数名称作用说明举例ansible_ssh_host# 用于指定被管理的主机的真实IPansible_ssh_host=192.168.1.1ansible_ssh_port# 用于指定连接到被管理主机的ssh端口号，默认是22ansible_ssh_port=2000ansible_ssh_user# ssh连接时默认使用的用户名ansible_ssh_user=dbaansible_ssh_pass# ssh连接时的密码ansible_ssh_pass=test1234ansible_sudo# sudo用户ansible_sudo=dbaansible_sudo_pass# 使用sudo连接用户时的密码ansible_ssh_pass=test1234ansible_sudo_exec# 如果sudo命令不在默认路径，需要指定sudo命令路径ansible_sudo_exec=/usr/bin/sudoansible_ssh_private_key_file# 秘钥文件路径，秘钥文件如果不想使用ssh-agent管理时可以使用此选项ansible_ssh_private_key_file=/root/keyansible_shell_type# 目标系统的shell的类型，默认shansible_shell_type=bashansible_connectionSSH 连接的类型： local , ssh , paramiko，在 ansible 1.2 之前默认是 paramiko ，后来智能选择，优先使用基于 ControlPersist 的 ssh （支持的前提）ansible_connection=localansible_python_interpreter# 用来指定python解释器的路径，默认为/usr/bin/python 同样可以指定ruby 、perl 的路径ansible_python_interpreter=/usr/bin/python2.7ansible_*_interpreter# 其他解释器路径，用法和ansible_python_interpreter类似，这里”*“可以是ruby或才perl等其他语言ansible_*_interpreter=/usr/bin/ruby\n指定python版本\n指定受控端python版本\n192.168.8.101 ansible_python_interpreter=/usr/bin/python2.7\n在受控端使用指定版本的python安装对应ansible module\n/usr/bin/python2.7 -m pip install xxxx\nAnsible Galaxy\nAnsible Galaxy是一个用于共享和管理Ansible角色的平台，当使用Ansible Galaxy创建或安装角色时，它会生成一种常见的目录结构，以便更好地组织和管理角色\n创建角色：使用ansible-galaxy init命令创建角色，并指定角色的名称，创建一个名为”my_role”的角色\nansible-galaxy init my_role\n\n典型目录结构\nrole_name/\n  ├── defaults/\n  │   └── main.yml\n  ├── files/\n  │   └── some_file.txt\n  ├── handlers/\n  │   └── main.yml\n  ├── meta/\n  │   └── main.yml\n  ├── tasks/\n  │   └── main.yml\n  ├── templates/\n  │   └── some_template.j2\n  ├── vars/\n  │   └── main.yml\n  └── README.md\n\n\ndefaults/：包含角色的默认变量，这些变量会被其他任务和角色使用\nfiles/：包含角色使用的静态文件，如配置文件或脚本\nhandlers/：包含角色的处理程序，用于处理特定的事件或触发器\nmeta/：包含角色的元数据，如作者、依赖项和支持的平台\ntasks/：包含角色的主要任务，即要执行的操作\ntemplates/：包含角色使用的模板文件，这些文件可以根据变量动态生成内容\nvars/：包含角色的变量文件，用于定义角色的变量值\nREADME.md：角色的说明和文档\n\nAnsible Galaxy\n\n搜索角色，使用ansible-galaxy search命令搜索Ansible Galaxy上的角色\n\n搜索名为”nginx”的角色\nansible-galaxy search nginx\n\n查看角色详情，使用ansible-galaxy info命令查看角色的详细信息\n\n查看名为”nginx”的角色的详细信息\nansible-galaxy info nginx\n\n安装角色，使用ansible-galaxy install命令安装角色，可以通过指定角色名称和可选的版本号来安装角色\n\n安装名为”nginx”的最新版本角色\nansible-galaxy install nginx\n安装特定版本的角色\nansible-galaxy install nginx,1.0.0\n\n使用角色，一旦安装了角色，可以使用roles关键字来指定要使用的角色\n\n---\n- name: My Playbook\n  hosts: all\n  roles:\n      - nginx\n\n管理角色，使用ansible-galaxy命令来管理已安装的角色\n\n\nansible-galaxy list命令列出已安装的角色\nansible-galaxy remove命令卸载角色\nansible-galaxy update命令更新角色\n\n关键字\nAnsible 是一个非常强大的自动化运维工具，它使用 YAML 格式的 Playbooks 来描述配置和任务，使得自动化任务变得清晰和易于管理。在 Ansible 中，有一些关键词和概念是经常使用的，下面列出了一些常见的关键词及其简单介绍：\n\nhosts: 定义目标主机，可以是单个主机名、IP 地址，也可以是主机组。例如，all, webservers, db_servers。\ntasks: Playbook 中的基本构建单元，用来执行具体的操作，如安装软件包、修改配置文件、重启服务等。\nplaybooks: YAML 文件，包含一系列的任务，用于描述一组主机上的自动化操作序列。Playbooks 是 Ansible 的主要配置文件。\nmodules: Ansible 提供的可执行代码片段，用于执行特定的任务。例如，apt, yum, file, command, shell 等模块。\nhandlers: 用于响应事件的特殊任务，比如在配置文件改变后重启服务。只有当被触发时，handler 才会被执行。\nroles: 将相关的任务、文件、模板和变量组织在一起的目录结构，用于实现模块化和重用。\nfacts: Ansible 收集的关于远程主机的信息，如操作系统、内核版本、网络接口等。可以通过变量访问这些信息，例如 ansible_os_family, ansible_distribution, ansible_all_ipv4_addresses。\nvariables: 用于存储和传递信息的容器，可以在 Playbooks 和 Tasks 中使用。例如，my_var, ansible_ssh_host。\ntags: 用于标记 Playbook 中的 tasks 或 plays，可以用于控制哪些任务在执行时被包含或跳过。\nwhen: 控制条件，用于指定某个 task 在满足特定条件下才执行。\nbecome: 用于执行需要更高权限的任务，相当于 sudo 或 su 的功能。可以通过 become: yes 或 sudo: yes 来启用。\ninclude_tasks: 用于在 Playbook 中包含另一个任务列表文件，实现任务的复用和模块化。\nimport_playbook: 在当前 Playbook 中导入并执行另一个 Playbook。\ndelegate_to: 用于将任务委托给另一台主机执行，而不是当前主机。\nrescue: 当一个任务失败时，执行 rescue 模块中的任务，用于错误处理。\nalways: 无论前面的任务是否成功，总是执行 always 模块中的任务，常用于清理操作。\nloop: 用于迭代执行任务，可以基于列表或其他可迭代对象。\nblock: 将多个任务组合在一起，用于一起应用 when, rescue, always 控制语句。\nregister: 将任务输出注册到一个变量中，以便后续任务使用。\nwith_items: 旧的迭代语法，已经被 loop 替换，但在一些老的 Playbooks 中仍然可见。\n\nModule\ncommand\ncommand模块是个可以在远端上执行指令的指令模组（Commands Modules），但它不支持变数（变量）和  &lt; ，  &gt;，  |，  ;  和  &amp; 等运算，若有这类请需求改用shell模块\n\nchdir：指定要在远程主机上执行命令的工作目录\ncreates：指定一个文件路径，如果该文件存在，则命令将不会执行\nexecutable：指定要执行的命令的可执行文件路径，例如/bin/bash\nremoves：指定一个文件路径，如果该文件不存在，则命令将不会执行\nwarn：默认为yes，如果设置为no，则不会在命令失败时发出警告\nstdin：将命令的标准输入设置为指定的字符串\nstdin_add_newline：默认为yes，如果设置为no，则不会在stdin末尾添加换行符\nstrip_empty_ends：默认为yes，如果设置为no，则不会去掉命令输出中的空行\ncmd：要在远程主机上执行的命令\n\nshell\nshell模块用于在远程主机上执行Shell命令\n\nchdir：指定要在远程主机上执行命令的工作目录\ncreates：指定一个文件路径，如果该文件存在，则命令将不会执行\nexecutable：指定要执行的命令的可执行文件路径，例如/bin/bash\nremoves：指定一个文件路径，如果该文件不存在，则命令将不会执行\nwarn：默认为yes，如果设置为no，则不会在命令失败时发出警告\nstdin：将命令的标准输入设置为指定的字符串\nstdin_add_newline：默认为yes，如果设置为no，则不会在stdin末尾添加换行符\nstrip_empty_ends：默认为yes，如果设置为no，则不会去掉命令输出中的空行\ncmd：要在远程主机上执行的Shell命令\n\n&gt; 和 | 有什么异同\n在 Ansible 中，shell 模块和其他模块一样，可以接受多行字符串作为参数值。当需要传递一个多行的命令或者脚本时，可以使用 &gt; 或 | 来定义这些多行字符串。这两种方式的主要区别在于如何处理空白字符（空格、制表符）和如何对文本进行折叠。\n使用 | (Pipe) 符号\n当使用 | 符号时，Ansible 会将下一行开始的文本作为多行字符串，直到下一个 | 符号出现或 YAML 文件结束。使用 | 时，所有缩进都会被忽略，只保留相对缩进。这意味着在 | 下方写的任何文本都将保持原样，除了最左侧的缩进会被移除。例如：\nshell: |\n  echo &quot;This is line one.&quot;\n  echo &quot;This is line two with extra tabs\\t\\tand spaces. &quot;\n在这个例子中，echo 命令后面的空白字符会被保留，而最左侧的缩进（通常是两个空格或一个制表符）会被移除。\n使用 &gt; 符号\n当使用 &gt; 符号时，Ansible 会像使用 | 一样创建一个多行字符串，但是它会对文本进行折叠，移除所有的前导缩进，并且将连续的空白字符压缩成一个空格。例如：\nshell: &gt;\n  echo &quot;This is line one.&quot;\n  echo &quot;This is line two with extra tabs\\t\\tand spaces. &quot;\n在这个例子中，所有的前导缩进会被移除，而且连续的空白字符（包括空格和制表符）会被压缩成一个空格。\nstat\nstat 模块用于获取文件或路径的状态信息\n\npath（必需）：要检查状态的文件或路径\nfollow：如果路径是符号链接，是否跟随链接获取链接指向的文件的状态，默认为 no，不跟随链接\nget_checksum：是否获取文件的校验和，默认为 no\nchecksum_algorithm：用于计算校验和的算法，仅当 get_checksum 为 yes 时有效，可选的值有 md5、sha1、sha224、sha256、sha384 和 sha512，默认为 md5\nget_md5、get_sha1、get_sha224、get_sha256、get_sha384、get_sha512：分别指定是否获取特定类型的校验和，这些选项会覆盖 get_checksum 和 checksum_algorithm\nfollow_ancestors：如果路径不存在，是否跟随祖先路径，默认为 no\nfile_type：用于检查文件类型的选项，可选的值有 file、directory、symlink、hard 和 socket，可以指定多个类型，以逗号分隔\nfile_gid、file_group：用于检查文件所属组的选项，可以指定组 ID 或组名\nfile_uid、file_owner：用于检查文件所有者的选项，可以指定用户 ID 或用户名\npath_stat：指定一个变量名，将状态信息存储在该变量中，而不是默认的 stat 变量\nfollow_mode：是否跟随路径获取模式，默认为 yes\n\n文件状态属性\n\nexists：文件是否存在，返回布尔值（true 或 false）\nisdir：文件是否是目录，返回布尔值\nisfile：文件是否是常规文件，返回布尔值\nisreg：文件是否是普通文件，返回布尔值\nislink：文件是否是符号链接，返回布尔值\nuid：文件的所有者用户 ID\ngid：文件的所有者组 ID\nmode：文件的权限模式，以八进制表示\nsize：文件的大小（字节）\nmtime：文件的修改时间戳\n\nfile\nfile模块用于管理文件和目录的属性和权限\n\npath：指定要管理的文件或目录的路径\nstate：指定文件或目录的状态，可以是file、directory、link、hard、touch等\nmode：指定文件或目录的权限模式，例如0644\nowner：指定文件或目录的所有者\ngroup：指定文件或目录的所属组\nrecurse：如果设置为yes，则递归地应用文件或目录的属性和权限\nfollow：如果设置为yes，则会跟随符号链接操作\nforce：如果设置为yes，在修改文件或目录属性时会强制执行\nselevel：指定SELinux安全标签的级别\nserole：指定SELinux安全标签的角色\nsetype：指定SELinux安全标签的类型\nseuser：指定SELinux安全标签的用户\n\ncopy\ncopy模块用于将文件或目录复制到远程主机\n\nsrc：指定要复制的源文件或目录的路径\ndest：指定目标文件或目录的路径\nbackup：如果设置为yes，在复制文件之前会创建备份文件\nforce：如果设置为yes，则即使目标文件已存在，也会强制复制文件\nmode：指定目标文件的权限模式，例如0644\nowner：指定目标文件的所有者\ngroup：指定目标文件的所属组\nremote_src：如果设置为yes，则将在远程主机上查找源文件\nvalidate：指定一个命令来验证复制的文件，如果验证命令不返回零，则会发出错误\nfollow：如果设置为yes，则会跟随源文件的符号链接进行复制\ncontent：将指定的内容复制到目标文件\n\ndebug\ndebug模块用于输出调试信息\n\nmsg：指定要输出的调试信息\nvar：指定要输出的变量的值\nverbosity：指定输出的详细程度，可以是0（只输出关键信息）、1（默认，输出一般信息）、2（输出详细信息）等\ndebugger_on：如果设置为yes，则在输出调试信息后启用调试器\n\nlineinfile\nlineinfile模块用于在文件中搜索并替换行\n\npath：指定要操作的文件的路径，\nline：指定要插入、修改或删除的行内容\nstate：指定行的状态，可以是present（存在）、absent（不存在）、before（在指定行之前插入）、after（在指定行之后插入）等\nregexp：指定用于搜索行的正则表达式\nbackrefs：如果设置为yes，则在替换行时可以在line中使用后向引用\ninsertafter：指定在哪一行之后插入新行\ninsertbefore：指定在哪一行之前插入新行\ndest：指定目标文件的路径，如果设置，则会将匹配的行复制到该文件中\nfirstmatch：如果设置为yes，则只匹配第一条满足条件的行\n\ngather_facts\ngather_facts模块用于收集目标主机的系统信息。它会自动执行一系列的任务来获取主机的各种属性，如操作系统类型、版本、主机名、IP地址、CPU和内存信息等。\n常见的参数选项如下：\n\ngather_subset：指定要收集的子集。可以是all（默认值）、hardware、network、virtual、ohai、facter等。可以使用逗号分隔多个子集。\ngather_timeout：指定收集信息的超时时间，单位为秒。默认为10秒。\nfilter：指定一个过滤器来选择要收集的主机。可以是一个主机模式，如web*，也可以是一个主机组名。\ngather_timeout_msg：指定超时时打印的错误消息。\ngather_subset：指定要收集的信息子集。\ngather_timeout：指定收集信息的超时时间。\ngather_timeout_msg：指定超时时的错误消息。\n\nbecome\nbecome功能允许在执行任务时切换到其他用户身份，例如root用户，以便执行需要特权的操作。\n常用的参数：\n\nbecome: true：表示启用become功能，默认情况下为false，需要手动设置为true才能使用become功能。\nbecome_user: &lt;username&gt;：指定切换到的目标用户，默认为root。可以指定其他具有特权的用户。\nbecome_method: &lt;method&gt;：指定切换用户的方法。常见的方法包括sudo和su，默认为sudo。\nbecome_flags: &lt;flags&gt;：指定切换用户时附加的标志。可用于指定sudo的附加标志。\nbecome_exe: &lt;executable&gt;：指定用于切换用户的可执行文件。默认情况下，根据become_method自动选择适当的可执行文件。\nansible_become_pass: &lt;password&gt;：指定become用户的密码。可以在剧本中明文指定密码，或者使用vault加密密码。\n\npre_tasks\npre_tasks是一组任务，这些任务会在playbook的主要任务之前执行。pre_tasks通常用于在执行主要任务之前进行一些准备工作，例如设置环境变量、安装前置依赖、检查目标主机状态等。\npre_tasks块可以在playbook的任何地方定义，通常位于playbook的顶层。它可以包含一个或多个任务，每个任务可以是一个单独的模块或一个包含多个模块的任务列表。\n以下是一个使用pre_tasks的示例：\n- name: Example playbook\n  hosts: myhosts\n  gather_facts: false\n  pre_tasks:\n    - name: Set environment variables\n      shell: export MY_VAR=my_value\n    - name: Install dependencies\n      apt:\n        name: my_package\n        state: present\n  tasks:\n    - name: Main task\n      # ...主要任务...\n在上面的例子中，pre_tasks块包含了两个任务：设置环境变量和安装依赖。这些任务会在执行主要任务之前依次执行。\n需要注意的是，pre_tasks块中的任务会在目标主机上按顺序执行，并且不受条件或循环控制的影响。如果pre_tasks中的任何任务失败，整个playbook都将失败，并且不会执行主要任务。\npre_tasks是一个可选项，根据实际需求决定是否使用。它通常用于执行一些必要的准备工作，以确保主要任务能够成功执行。\nregister\nAnsible中的register关键字用于捕获任务（task）的输出，并将其保存到一个变量中，这样可以在后续的任务中调用这个变量。这种机制允许用户在执行特定操作后，根据操作的结果来决定如何响应，例如执行其他Ansible语句或进行条件判断等。通过使用register，可以将命令、模块或任务的输出存储到变量中，这不仅限于单个playbook内的使用，而且在不同的playbook之间也可以共享这些变量。例如，我们使用register将stat模块的结果保存到file_stat变量中：\n- name: Check if file exists\n  stat:\n    path: /path/to/file\n  register: file_stat\n这将执行stat模块来检查文件是否存在，并将结果保存到file_stat变量中。然后，可以在后续任务中引用file_stat变量来获取之前任务的结果。在copy任务中使用了file_stat变量，以便根据文件是否存在来决定是否标记任务为”changed”：\n- name: Create file if it doesn&#039;t exist\n  copy:\n    src: /path/to/source\n    dest: /path/to/file\n  changed_when: &quot;&#039;file_stat.stat.exists&#039; == &#039;False&#039;&quot;\n\n使用了file_stat.stat.exists来访问之前stat模块的结果中的文件存在信息。如果文件不存在，则任务被标记为”changed”。\nchanged_when\nchanged_when参数用于指定在哪些情况下标记任务为”changed”（已更改）。默认情况下，如果任何模块的返回结果中存在变化，则任务将被标记为”changed”。\n为保证ansible代码的规范，在任务中需要明确是否返回对结果或条件的更改。除非任务只读取信息，否则应确保它们以以下方式返回更改：\n\n注册结果或条件并使用changed_when子句。\n使用creates或removes参数。\n\nchanged_when参数可以使用以下方式指定：\n\n布尔值：当指定为True时，任务总是被标记为”changed”；当指定为False时，任务总是被标记为”ok”。\n字符串：任务的输出将与指定的字符串进行比较。如果匹配，则任务被标记为”ok”；如果不匹配，则任务被标记为”changed”。可以使用Jinja2模板语法来引用变量。\nPython表达式：可以使用Python表达式来指定任务的返回结果是否应被标记为”changed”。可以使用Jinja2模板语法来引用变量。\n\n示例：\n- name: Check if file exists\n  stat:\n    path: /path/to/file\n  register: file_stat\n  \n- name: Create file if it doesn&#039;t exist\n  copy:\n    src: /path/to/source\n    dest: /path/to/file\n  changed_when: &quot;&#039;file_stat.stat.exists&#039; == &#039;False&#039;&quot;\n首先使用stat模块检查文件是否存在，并将结果存储在file_stat变量中。然后，使用copy模块复制文件。如果文件不存在（即file_stat.stat.exists为False），则任务被标记为”changed”，否则被标记为”ok”。\nfqcn\n在Ansible中，Fully Qualified Collection Name（FQCN）是一种用于指定模块、插件或动作的完整集合名称的方法。这种做法有助于避免命名冲突和提高代码的可读性。从Ansible 2.10版本开始，许多插件和模块已经迁移到了Collections上，这意味着它们现在属于特定的命名空间，如ansible.builtin 或自定义命名空间。使用FQCN可以确保操作使用的是正确的命名空间中的代码，从而避免了潜在的歧义和冲突。\n例如，如果想要使用shell模块，而不是简单地写shell，应该使用其FQCN ansible.builtin.shell。同样，当引用一个集合的内容时，也可以通过FQCN来指定，如my_namespace.my _collection.my _module。此外，即使是在ansible-core中，也推荐使用FQCN来明确指出要使用的模块或插件，以避免与其他可能存在的集合发生冲突，并便于链接到模块文档。\n在迁移Ansible playbook和角色时，强烈建议使用FQCN以避免意外行为。这是因为FQCN提供了一种更清晰的方式来指定使用的模块或插件的确切来源，尤其是在存在多个集合包含相同名称的模块或插件时。此外，使用FQCN还有助于保持Ansible内容的质量，通过遵循最佳实践，可以预防潜在的问题并维护一致且高效的自动化脚本。\nFQCN是Ansible中一个重要的概念，它通过提供一个明确的命名空间来帮助开发者避免命名冲突，提高代码的可维护性和可读性。在编写Ansible剧本时，应当尽可能地使用FQCN来指定所需的模块、插件或动作。\n示例：\n- name: Hello world\n  ansible.builtin.command:\n    cmd: echo &#039;hello world&#039;\n  changed_when: false\nservice\nservice模块用于管理系统服务的状态\n\nname：指定要管理的服务的名称\nstate：指定服务的状态，可以是started（启动）、stopped（停止）、restarted（重新启动）、reloaded（重新加载）等\nenabled：如果设置为yes，则在系统启动时启用服务\ndisabled：如果设置为yes，则在系统启动时禁用服务\npattern：指定用于匹配服务进程的模式，可以是进程名称、进程ID等\narguments：指定启动服务时要传递的附加参数\nsleep：指定在重新启动或重新加载服务之前等待的时间，以秒为单位\ntimeout：指定等待服务状态变化的超时时间，以秒为单位\nrunlevel：指定服务在哪个运行级别下启动\n\nuser\nuser模块用于管理系统用户，下面是一些常用的参数选项的介绍：\n\nname：指定要管理的用户的用户名\nstate：指定用户的状态，可以是present（存在）、absent（不存在）、locked（锁定）等\nuid：指定用户的用户ID\npassword：指定用户的密码，可以是明文密码，也可以是加密后的密码\ngroup：指定用户所属的主组\ngroups：指定用户所属的附加组\nshell：指定用户的默认shell\nhome：指定用户的家目录路径\ncreatehome：如果设置为yes，则在创建用户时创建家目录\nremove：如果设置为yes，则在删除用户时同时删除家目录\nmove_home：如果设置为yes，则在修改用户家目录路径时同时移动家目录\nnon_unique：如果设置为yes，则允许非唯一的用户ID\n\nlvm\nlvm模块用于管理逻辑卷管理器（LVM）\n\nvg：指定要管理的卷组的名称\npvs：指定要创建物理卷的设备\nlvs：指定要创建逻辑卷的卷组和逻辑卷的配置\nstate：指定卷组、物理卷或逻辑卷的状态，可以是present（存在）、absent（不存在）等\nresizefs：如果设置为yes，则在调整逻辑卷大小后同时调整文件系统大小\nforce：如果设置为yes，则在删除逻辑卷或卷组时强制执行\nzero：如果设置为yes，则在删除物理卷时将其填充为零\npvresize：如果设置为yes，则在创建或删除物理卷后调整物理卷的大小\nfstype：指定逻辑卷上的文件系统类型\n\nmount\nAnsible的mount模块主要用于管理被控端设备的挂载，包括挂载和卸载操作。该模块的基本功能是配置文件系统的挂载点，以及与之相关的参数设置。\nmount模块主要用于管理被控端设备的挂载，包括挂载和卸载操作。该模块的基本功能是配置文件系统的挂载点，以及与之相关的参数设置。\n\nstate：指定挂载点的状态，可以是present（表示挂载点存在）或mounted（表示挂载点已挂载）。这是执行挂载操作时必须指定的参数之一。\nsrc：指定要挂载的设备或文件系统的路径。这个参数是必需的，用于明确挂载源的位置。\npath：指定设备挂载至本地的路径，即挂载点。这个参数也是必需的，用于定义挂载的目标位置。\nfstype：指定挂载的文件系统类型，如ext4、nfs等。当state为present或mounted时，此参数是必需的。\nopts：挂载选项，用于指定挂载时的具体参数，如权限、同步模式等。这些选项可以根据需要进行自定义。\ndest：虽然在一些文档中提到，但实际上在官方文档和示例中并未明确提及此参数。它可能是一个误导信息，或者是在特定上下文中使用的非标准参数。\nusername和password：在某些情况下，如果挂载源是基于网络的共享（如NFS），可能需要提供用户名和密码来访问共享资源。这些参数用于指定访问共享时的身份验证信息。\nsync：指定将文件系统挂载为同步模式，确保数据立即写入磁盘，适用于需要高数据一致性的场景。\n\nyum\nyum模块用于管理CentOS或Red Hat系统上的软件包\n\nname：指定要安装、卸载或更新的软件包的名称\nstate：指定软件包的状态，可以是present（存在）、absent（不存在）、latest（最新）等\nupdate_cache：如果设置为yes，则在安装软件包之前会更新软件包缓存\ndisablerepo：指定要禁用的软件源\nenablerepo：指定要启用的软件源\ndisable_gpg_check：如果设置为yes，则会禁用软件包的GPG检查\ninstallroot：指定软件包的安装根目录\nexclude：指定要排除的软件包\nskip_broken：如果设置为yes，则会跳过损坏的软件包\ndisable_excludes：如果设置为yes，则会禁用软件包的排除规则\n\n示例\n- name: install httptd\n  yum: name=httpd state=present\n  \n- name: start httpd\n  service: name=httpd state=started\npip\npip模块用于管理Python包\n\nname：指定要安装、卸载或更新的Python包的名称\nstate：指定Python包的状态，可以是present（存在）、absent（不存在）、latest（最新）等\nexecutable：指定要使用的pip可执行文件的路径\nextra_args：指定要传递给pip的额外参数\nrequirements：指定一个要安装的包的要求文件路径\nvirtualenv：指定一个虚拟环境的路径，安装包将被限制在该环境中\neditable：如果设置为yes，则使用可编辑模式安装包\nchdir：指定要切换到的目录，然后执行pip命令\numask：指定安装包时的umask值\nproxy：指定代理服务器的URL\n\ngit\ngit模块用于管理Git仓库\n\nrepo：指定要克隆或更新的Git仓库的URL\ndest：指定要克隆或更新的目标目录的路径\nversion：指定要检出的Git分支、标签或提交的版本号\naccept_hostkey：如果设置为yes，则接受远程主机的SSH密钥\nforce：如果设置为yes，则强制执行克隆或更新操作\nkey_file：指定用于身份验证的SSH私钥文件的路径\nrecursive：如果设置为yes，则递归地克隆或更新Git子模块\nclone：如果设置为yes，则会执行克隆操作；如果设置为no，则只会执行更新操作\ndepth：指定克隆仓库时的深度，即最近的提交数量\nbare：如果设置为yes，则克隆一个裸仓库\n\ncron\ncron模块用于管理定时任务（cron jobs）\n\nname：指定要管理的定时任务的名称\nuser：指定定时任务所属的用户\njob：指定定时任务的命令\nstate：指定定时任务的状态，可以是present（存在）、absent（不存在）等\nminute：指定定时任务执行的分钟数\nhour：指定定时任务执行的小时数\nday：指定定时任务执行的日期\nmonth：指定定时任务执行的月份\nweekday：指定定时任务执行的星期几\nreboot：如果设置为yes，则定时任务将在系统重启后执行\nspecial_time：指定特殊的定时任务执行时间，如@reboot（系统重启后）、@daily（每天）、@weekly（每周）等\njob_file：指定定时任务的文件路径\nbackup：如果设置为yes，则在修改定时任务时备份原始文件\nstate_file：指定保存定时任务状态的文件路径\n\nfetch\nfetch模块用于从远程主机复制文件到控制节点\n\nsrc：指定要复制的远程主机上的文件路径\ndest：指定目标文件或目录的路径\nflat：如果设置为yes，则在目标目录中只创建一个文件，而不是使用远程主机上的完整路径\nvalidate_checksum：如果设置为yes，则在复制文件之前检查文件的校验和\nmd5sum_file：指定一个文件路径，用于存储远程主机上文件的校验和\nbackup：如果设置为yes，在复制文件之前会创建备份文件\nforce：如果设置为yes，则即使目标文件已存在，也会强制复制文件\n\ntemplate\ntemplate模块用于根据模板文件生成配置文件\n\nsrc：指定模板文件的路径\ndest：指定生成的配置文件的路径\nowner：指定生成的配置文件的所有者\ngroup：指定生成的配置文件的所属组\nmode：指定生成的配置文件的权限模式\nbackup：如果设置为yes，则在生成配置文件之前备份原始文件\nvalidate：指定一个自定义的命令或脚本来验证生成的配置文件\nforce：如果设置为yes，则强制生成配置文件，即使目标文件已经存在\nbecome：如果设置为yes，则以超级用户身份生成配置文件\nvars：指定要传递给模板文件的变量\nunsafe_writes：如果设置为yes，则使用不安全的写入方式生成配置文件\n\nraw\nraw是一种执行原始命令的模块。它允许在目标主机上执行未经过Ansible模块化处理的命令，以实现更灵活的操作。\nraw模块的使用方法是通过在playbook中定义一个任务，并使用raw关键字指定要执行的命令。以下是一个使用raw模块的示例：\n- name: Run raw command\n  hosts: myhosts\n  tasks:\n    - name: Execute raw command\n      raw: echo &quot;Hello, world!&quot;\nraw模块的一些常见参数选项如下：\n\nfree_form：要执行的原始命令。可以是一个字符串，也可以是一个命令列表。\nexecutable：指定要用于执行命令的可执行文件。默认值为/bin/sh。\nchdir：指定要在其中执行命令的目录。\nstdin：将标准输入传递给命令的内容。\n\n需要注意的是，raw模块执行的命令在目标主机上执行时，不会像其他Ansible模块那样受到Ansible的幂等性控制。这意味着执行相同的raw命令可能会导致不同的结果，具体取决于目标主机的状态和环境。\n由于raw模块是直接执行命令，因此在使用时需要谨慎，确保命令的安全性和正确性。\ndocker_*\ndocker_*模块用于管理Docker容器和镜像\n\n\ndocker_container模块\n\nname：指定要操作的容器的名称\nimage：指定要使用的镜像\nstate：指定容器的状态，可以是started（启动）、stopped（停止）、restarted（重启）、absent（删除）等\nrestart_policy：指定容器的重启策略\nports：指定容器的端口映射\nvolumes：指定容器的卷挂载\nenv：指定容器的环境变量\ncommand：指定容器的启动命令\n\n\n\ndocker_image模块\n\nname：指定要操作的镜像的名称\nsource：指定要使用的镜像源\nstate：指定镜像的状态，可以是present（存在）、absent（不存在）等\npull：如果设置为yes，则会拉取最新的镜像\nforce：如果设置为yes，则会强制拉取镜像，即使已经存在\n\n\n\ndocker_login模块\n\nregistry_url：指定要登录的Docker注册表的URL\nusername：指定登录的用户名\npassword：指定登录的密码\nemail：指定登录的电子邮件地址\n\n\n"},"自动化和编程/git":{"title":"git","links":[],"tags":["自动化和编程"],"content":"删除本地分支并同步远程\n要删除本地分支并同步到远程仓库：首先删除本地分支，然后删除远程分支\n1. 删除本地分支\n可以使用 git branch 命令来列出所有分支，然后使用 git branch -d &lt;branch_name&gt; 或 git branch -D &lt;branch_name&gt; 来删除本地分支。\n\n-d 选项用于删除已经合并到当前分支的分支。\n-D 选项用于强制删除尚未合并的分支（请注意大写 “D”）。\n\n例如，要删除名为 feature-branch 的本地分支，可以执行：\ngit branch -d feature-branch\n或者，如果该分支尚未合并，则使用：\ngit branch -D feature-branch\n2. 删除远程分支\n在删除了本地分支后，需要删除远程仓库中的对应分支。可以通过 git push 命令的 :&lt;branch_name&gt; 语法来实现。\n例如，要删除名为 feature-branch 的远程分支，可以执行：\ngit push origin :feature-branch\n或者可以使用更简洁的 git push 选项 -delete（在某些 Git 版本中可用）：\ngit push origin --delete feature-branch\n显示仓库引用列表/测试仓库是否存在\ngit ls-remote http://xxx.git\n查看git本地信息\ngit config --list\n \n# 查看用户名和邮箱\ngit config user.name\ngit config user.email\n更新仓库remote链接\ngit remote set-url origin http://xxxxx.git\n拉取全部信息\ngit fetch -a\n切换到上一个分支\ngit checkout -\n内容比较\n比较工作区和暂存区不同\ngit diff\n比较两个 commit 之间的文件变动\ngit diff &lt;commit-id&gt; &lt;commit-id&gt;\n查看所有分支\ngit ls-remote --heads ssh://git@10.254.180.148:20495/PZCPHPT.ZDHBS/auto_upgrade_script.git\n克隆最近一次提交\ngit clone --depth=1 ssh://git@10.254.180.148:20495/PZCPHPT.ZDHBS/auto_upgrade_script.git\n配置用户名、邮箱\n配置当前项目\ngit config user.name &quot;chengyh&quot;\ngit config user.email &quot;977599667@qq.com&quot;\n查看当前配置\ngit config --list\n配置全局设置\ngit config --global user.name chyuhung\ngit config --global user.email 977599667@qq.com\n查看全局配置\ngit config --global --list\n取消全局配置\ngit config --global --unset user.name\ngit config --global --unset user.email\n回到远程仓库状态\n硬重置本地，将当前分支重置到远程仓库中 origin 的 dev 分支的最新提交\ngit reset --hard origin/dev\n大仓库拉取\n拉取最近一次\n1、拉取指定分支\ngit clone -b dev ssh://git@xxxx/xxxx/auto_deploy_script.git\n2、指定分支并只拉取最近一次提交\ngit clone -b dev --depth=1 ssh://git@xxxx/xxxx/auto_upgrade_script.git\n新建空仓库拉取\n1、本地直接新建对应仓库\nmkdir &lt;repo名称&gt;\n2、初始化git仓库（即新建.git/）\ngit init\n3、配置remote origin\ngit remote add origin &lt;repo地址&gt;\n4、新建待拉取对应分支（默认为master）\ngit checkout -b &lt;对应分支名&gt;\n5、拉取特定分支\ngit pull origin &lt;对应分支名&gt;\n分支合并\n1、切换到特定分支并拉取最新代码，完成相关代码修改提交\ngit checkout feature-compmgmt1015\ngit pull\n2、切换到主分支，拉取最新代码\ngit  checkout dev\ngit pull\n3、合并代码到主分支\ngit merge feature-compmgmt1015\n# 解决有合并冲突的文件\n# git restore &lt;非我们改动的文件&gt;\n# git add . &amp;&amp; git commit -m &#039;解决有合并冲突的文件&#039;\ngit push\n4、查看git日志\ngit log\n5、恢复文件\ngit restore --staged .\ngit restore  .\n6、显示指定commit修改内容\ngit show 685b7067992b4ee1230fe38cc1c9dec2beb60e55\ngit status\n合并冲突，放弃合并\n放弃合并\ngit merge --abort\n并重置本地分支到远程状态\ngit reset --hard origin/主分支名称\n分支跟踪\n设置本地dev分支跟踪远程dev分支\n$ git remote -v\norigin  ssh://git@xxxx/xxxx/auto_upgrade_script.git (fetch)\norigin  ssh://git@xxxx/xxxx/auto_upgrade_script.git (push)\n \n$ git checkout dev\nSwitched to branch &#039;dev&#039;\n \n$  git branch --set-upstream-to=origin/dev dev\nbranch &#039;dev&#039; set up to track &#039;origin/dev&#039;.\n暂存\ngit stash 用于暂时保存当前工作目录的修改（包括暂存区和未暂存的修改）\n基本用法\n\n暂存当前修改\n\ngit stash\n这将保存所有未提交的修改并将工作目录恢复到最新提交的状态。\n\n查看已保存的stash\n\ngit stash list\n\n恢复最近的stash\n\ngit stash apply\n应用最近一次保存的stash，但不会删除该stash。\n\n恢复并删除最近的stash\n\ngit stash pop\n\n恢复指定的stash\n\ngit stash apply stash@{n}\n其中 n 是 git stash list 命令中显示的stash索引。\n\n删除指定的stash\n\ngit stash drop stash@{n}\n\n清除所有stashes\n\ngit stash clear\n示例\n使用 git stash 来保存当前的工作：\n# 暂存当前修改\ngit stash\n \n# 切换到需要修复bug的分支\ngit checkout bugfix-branch\n \n# 修复bug并提交\ngit commit -am &quot;Fix critical bug&quot;\n \n# 切换回开发新功能的分支\ngit checkout feature-branch\n \n# 恢复之前的修改\ngit stash pop"},"自动化和编程/github-actions":{"title":"github actions","links":[],"tags":["自动化和编程"],"content":""},"自动化和编程/自动化和编程":{"title":"自动化和编程","links":[],"tags":[],"content":"\n\n自动化和编程\n\n自动化工具（如 Ansible、Chef、Puppet）\n脚本编程和编写自动化脚本\n版本控制系统（如 Git、SVN）\n\n\n"}}