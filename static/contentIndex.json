{"index":{"title":"welcome to my digital garden","links":["tags"],"tags":[],"content":"数字花园 是我的一种全新的尝试，既然叫做数字花园，那么我希望它应该向阳而肆意生长，摆脱苦恼与烦闷！\n开始浏览我的数字花园tags\n搭建数字花园（Quartz）官方文档 Welcome to Quartz 4 (jzhao.xyz)\n\n我的数字花园部署结构\n\n私有仓库（quartz-obsidian） ⇒ git actions部署pages ⇒ 公开仓库（chyuhung.github.io）\n\ngit actions 代码\n\nname: Deploy Quartz site to GitHub Pages\n \non:\n  push:\n    branches:\n      - v4\n \npermissions:\n  contents: read\n  pages: write\n  id-token: write\n \nconcurrency:\n  group: &quot;pages&quot;\n  cancel-in-progress: false\n \njobs:\n  build:\n    runs-on: ubuntu-22.04\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0 # Fetch all history for git info\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 18.14\n      - name: Install Dependencies\n        run: npm ci\n      - name: Build Quartz\n        run: npx quartz build\n      - name: Deploy to GitHub Pages\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.ID_RSA_HUGO_DEPLOY }}\n          external_repository: chyuhung/chyuhung.github.io\n          publish_branch: main\n          publish_dir: ./public\n          commit_message: ${{ github.event.head_commit.message }}\n\nkey配置\n\n使用ssh-keygen生成一对公钥和密钥，在代码仓库（quartz-obsidian）secrets中添加私钥，在pages仓库（chyuhung.github.io）添加公钥\n\n勿以善小而不为\n\n如有错误欢迎指正！"},"tags":{"title":"tags","links":["基础技能/基础技能","自动化和编程/自动化和编程","云计算和虚拟化/云计算和虚拟化","应用部署和容灾/应用部署和容灾","监控和日志管理/监控和日志管理","安全和权限管理/安全和权限管理","网络和存储管理/网络和存储管理","故障排除和性能优化/故障排除和性能优化","文档和沟通能力/文档和沟通能力"],"tags":[],"content":"\n\n基础技能\n\n操作系统（如 Linux、Unix、Windows）的基本原理和命令行操作\n网络协议和网络基础知识\n编程基础（如 Python、Shell、Perl）\n\n\n\n自动化和编程\n\n自动化工具（如 Ansible、Chef、Puppet）\n脚本编程和编写自动化脚本\n版本控制系统（如 Git、SVN）\n\n\n\n云计算和虚拟化\n\n云计算基础概念和服务模型（如 IaaS、PaaS、SaaS）\n虚拟化技术（如 VMware、KVM、Docker）\n容器编排和管理工具（如 Kubernetes）\n\n\n\n应用部署和容灾\n\nWeb 服务器和应用服务器的部署和配置（如 Nginx、Apache、Tomcat）\n高可用性和容灾技术（如负载均衡、故障转移、备份恢复）\n\n\n\n监控和日志管理\n\n监控系统的搭建和配置（如 Zabbix、Prometheus）\n日志管理和分析工具（如 ELK Stack、Splunk）\n\n\n\n安全和权限管理\n\n系统安全和漏洞管理\n访问控制和权限管理（如 LDAP、RBAC）\n防火墙和网络安全配置\n\n\n\n网络和存储管理\n\n网络设备的配置和管理\n存储管理和数据备份策略\n数据库管理（如 MySQL、PostgreSQL、MongoDB）\n\n\n\n故障排除和性能优化\n\n系统故障排查和调优\n性能监测和性能优化技术\n容量规划和资源管理\n\n\n\n文档和沟通能力\n\n技术文档编写和维护\n团队协作和沟通能力\n问题解决和故障处理技巧\n\n\n"},"云计算和虚拟化/k8s":{"title":"k8s","links":[],"tags":[],"content":"资源介绍和常用命令\nnamespace\n用于在集群中创建逻辑隔离的虚拟集群。命名空间允许将集群划分为多个独立的单元，每个单元具有自己的资源配额和访问控制策略\n查看集群所有命名空间\nkubectl get ns\n设置命名空间变量，方便使用\nOP_NAMESPACE=paas-ucrs\npod\n是Kubernetes中最小的可调度和可管理的单元。它是一个或多个容器的集合，它们共享相同的网络和存储上下文。Pod提供了一种逻辑主机，容器共享相同的IP地址和端口空间\n查看指定命名空间的所有pod\nkubectl get pods -n ${OP_NAMESPACE} \n查看pod信息\nkubectl describe pods -n ${OP_NAMESPACE} &lt;pod_name&gt;\n删除/重启pod\nkubectl delete pods -n ${OP_NAMESPACE} &lt;pod_name&gt;\n进入pod\nkubectl exec -it -n ${OP_NAMESPACE} &lt;pod_name&gt; bash\n\n查看pod最新日志，打印200行\nkubectl logs --tail=200 -n ${OP_NAMESPACE} &lt;pod_name&gt;\ndeployment\n用于定义可扩展和自愈的应用程序副本集。Deployment对应于Pod的副本控制器，它负责管理Pod的创建、更新和删除，以确保所需的副本数一直保持在活动状态\n编辑deployment\nkubectl edit deployment -n ${OP_NAMESPACE}\n删除deployment\nkubectl delete deployment -n ${OP_NAMESPACE} \n获取deployment信息，yaml格式输出\nkubectl get deployment -n ${OP_NAMESPACE} &lt;deployment_name&gt; -o yaml\n调整副本数量\nkubectl scale deployment --replicas=1 -n ${OP_NAMESPACE} &lt;deployment_name&gt;\n查看历史\nkubectl rollout history -n ${OP_NAMESPACE} deployment/&lt;deployment_name&gt;\n回滚到指定版本\nkubectl rollout undo -n ${OP_NAMESPACE} deployment/&lt;deployment_name&gt; --to-revision=&lt;num&gt;\n创建资源\nkubectl create -f &lt;filename.yml&gt;\n更新/创建资源\nkubectl apply -f &lt;filename.yml&gt;\nservice\n定义了一组Pod的访问方式和网络终结点。Service具有稳定的IP地址和DNS名称，并通过标签选择器将流量路由到后端的Pod。它可以提供负载均衡、服务发现和连接到后端应用程序的稳定入口\n编辑service\nkubectl edit service -n ${OP_NAMESPACE} &lt;service_name&gt;\nvirtualService\n查看所有vs\nkubectl get vs -A\n获取指定格式vs\nkubectl get vs -n &lt;nsname&gt; &lt;vsname&gt; -o yaml\n编辑vs\nkubectl edit vs -n &lt;nsname&gt; &lt;vsname&gt;\n\nconfigMap\n于将非敏感的配置数据注入到Pod中。ConfigMap可以存储键值对、文件或目录，并可以在Pod中以环境变量、命令行参数或卷的形式使用\n创建cm\nkubectl create configmap -n ${OP_NAMESPACE} &lt;cmname&gt; --from-file=&lt;filepath&gt;\n编辑cm\nkubectl edit configmap -n ${OP_NAMESPACE} &lt;cmname&gt;\n删除cm\nkubectl delete configmap -n ${OP_NAMESPACE} &lt;cmname&gt;\nimage\n更新镜像\nkubectl set image deploy -n ${OP_NAMESPACE} &lt;deployment_name&gt;\n查看镜像版本，使用jsonpath模板来按指定格式输出结果\nkubectl get pods -n ${OP_NAMESPACE}  -o=jsonpath=&#039;{range .items[*]}{.metadata.name}{&quot;\\t&quot;}{.spec.containers[*].image}{&quot;\\n&quot;}{end}&#039;\n\nkubectl get pods -n ${OP_NAMESPACE}: 用于获取指定命名空间（${OP_NAMESPACE}）中的所有Pods的信息\n-o=jsonpath=&#039;{range .items[*]}{.metadata.name}{&quot;\\t&quot;}{.spec.containers[*].image}{&quot;\\n&quot;}{end}&#039;: 使用jsonpath模板来输出结果\n&#039;{range .items[*]}:使用range关键字来迭代所有的Pods对象\n{.metadata.name}: 输出每个Pod的名称\n{&quot;\\t&quot;}: 在名称和镜像之间添加一个水平制表符\n{.spec.containers[*].image}: 输出每个Pod中所有容器的镜像信息\n{&quot;\\n&quot;}: 在每个Pod的信息之间添加一个换行符\n{end}: 结束range循环\n\n综合起来，命令将输出指定命名空间中所有Pods的名称和每个Pod中所有容器的镜像信息，每个Pod的信息用制表符分隔，每个Pod之间用换行符分隔\nstatefulSet\n用于管理有状态应用程序的副本集。StatefulSet为每个Pod分配唯一的标识符和网络标识，以便在Pod重新启动或扩展时保持稳定\nsecret\n用于安全地存储敏感信息，如密码、API密钥等。Secret以Base64编码的形式存储，并可以在Pod中以环境变量、命令行参数或卷的形式使用\npersistentVolume\n用于将持久化存储资源抽象为Kubernetes中的卷。它独立于Pod的生命周期，并提供了持久性和数据的跨Pod共享\njob\n用于在集群中运行一次性任务或批处理任务。它确保任务成功完成，并且可以设置重试和并行性。Job创建一个或多个Pod来运行任务，当任务完成时，它们会自动终止。Job适用于需要执行一次性任务或需要确保任务的完整性的场景\ncronJob\n基于类似于Unix cron的时间表达式来定期运行任务。它创建一个Job来运行预定义的任务，并可以设置任务的调度时间和重试策略。CronJob适用于需要定期执行的任务，如定时备份、数据清理等\ningress\n将外部流量路由到集群内部服务的规则和配置。它充当了外部流量的入口点，并提供负载均衡、SSL终止和基于域名的路由等功能。Ingress通过定义规则和使用反向代理来将外部请求路由到相应的服务。它可以与不同的Ingress控制器配合使用，如Nginx Ingress Controller、Traefik等"},"云计算和虚拟化/openstack":{"title":"openstack","links":[],"tags":["云计算和虚拟化"],"content":"openstack集群健康检查\nopenstack-status"},"云计算和虚拟化/云计算和虚拟化":{"title":"云计算和虚拟化","links":[],"tags":[],"content":"\n\n云计算和虚拟化\n\n云计算基础概念和服务模型（如 IaaS、PaaS、SaaS）\n虚拟化技术（如 VMware、KVM、Docker）\n容器编排和管理工具（如 Kubernetes）\n\n\n"},"基础技能/go":{"title":"go","links":[],"tags":["基础技能"],"content":""},"基础技能/python":{"title":"python","links":[],"tags":["基础技能"],"content":"初识Python\n版本\n版本号分为三段，形如A.B.C，版本大更新增加A，新功能增加B，小改动增加C\n优缺点\n优点\n\n简单，学习曲线低\n开放源代码，生态强大\n解释型语言移植性强\n支持面向对象和函数式编程\n代码规范可读性强\n\n缺点\n\n执行效率稍微低\n代码无法加密\n\n解释器\n官方的Python解释器是用C语言实现的，也是使用最为广泛的Python解释器，通常称之为CPython\n应用领域\n后端开发、DevOps、爬虫、自动化测试、数据分析、机器学习\n运行\n单行注释以#开头，多行注释以&#039;&#039;&#039;开头和结尾\n# hello world 示例\nprint(&#039;hello, world!&#039;)\n开发工具\n安装python 自带集成开发工具IDLE（命令行交互式），实际开发不方便使用，通常使用pycharm或者vscode\n语言元素\n以python3进行总结\n\n整型 int 0b100 0x100 0o100\n浮点型 123.456\n字符串 “hello”\n布尔 true和false\n复数 与数学的i不同，使用j表示\n\n在python中可以使用type函数对类型进行检查\na = 100\nb = 12.345\nc = 1 + 5j\nd = &#039;hello, world&#039;\ne = True\nprint(type(a))    # &lt;class &#039;int&#039;&gt;\nprint(type(b))    # &lt;class &#039;float&#039;&gt;\nprint(type(c))    # &lt;class &#039;complex&#039;&gt;\nprint(type(d))    # &lt;class &#039;str&#039;&gt;\nprint(type(e))    # &lt;class &#039;bool&#039;&gt;\n变量命名\n硬性规则\n\n字母、数字和下划线，数字不开头\n大小写敏感\n关键词和系统保留字不可用\n\nPEP 8要求\n\n小写字母，多个单词使用下划线\n受保护实例属性下划线开头\n私有实例属性两个下划线开头\n\n运算符\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符描述[] [:]下标，切片**指数~ + -按位取反, 正负号* / % //乘，除，模，整除+ -加，减&gt;&gt; &lt;&lt;右移，左移&amp;按位与^ |按位异或，按位或&lt;= &lt; &gt; &gt;=小于等于，小于，大于，大于等于== !=等于，不等于is is not身份运算符in not in成员运算符not or and逻辑运算符= += -= *= /= %= //= **= &amp;=运算赋值\n分支结构\nif x &gt; 1:\n    y = 3 * x - 5\nelif x &gt;= -1:\n    y = x + 2\nelse:\n    y = 5 * x + 3\n循环结构\nfor x in range(101):\n    sum += x\n\n\nrange(1, 101, 2) 产生1到100的奇数，2是步长\n\nwhile True:\n    number = int(input(&#039;请输入: &#039;))\n    if number &lt; 1:\n        print(&#039;1&#039;)\n    elif number &gt; 1:\n        print(&#039;0&#039;)\n    else:\n        print(&#039;-1&#039;)\n        break\nbreak终止所在的循环, continue放弃本次循环后续的代码\n函数和模块\ndef关键字定义函数，return关键字返回值\ndef fac(num):\n    &quot;&quot;&quot;求阶乘&quot;&quot;&quot;\n    result = 1\n    for n in range(1, num + 1):\n        result *= n\n    return result\n函数参数\nPython中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载\nfrom random import randint\n \n \ndef roll_dice(n=2):\n    &quot;&quot;&quot;摇色子&quot;&quot;&quot;\n    total = 0\n    for _ in range(n):\n        total += randint(1, 6)\n    return total\n \n \ndef add(a=0, b=0, c=0):\n    &quot;&quot;&quot;三个数相加&quot;&quot;&quot;\n    return a + b + c\n \n \n# 如果没有指定参数那么使用默认值摇两颗色子\nprint(roll_dice())\n# 摇三颗色子\nprint(roll_dice(3))\nprint(add())\nprint(add(1))\nprint(add(1, 2))\nprint(add(1, 2, 3))\n# 传递参数时可以不按照设定的顺序进行传递\nprint(add(c=50, a=100, b=200))\n如果会对0个或多个参数进行加法运算，在不确定参数个数的时候，可以使用可变参数\n# 在参数名前面的*表示args是一个可变参数\ndef add(*args):\n    total = 0\n    for val in args:\n        total += val\n    return total\n \n \n# 在调用add函数时可以传入0个或多个参数\nprint(add())\nprint(add(1))\nprint(add(1, 2))\nprint(add(1, 2, 3))\nprint(add(1, 3, 5, 7, 9))\n模块管理函数\n如果在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的\ndef foo():\n    print(&#039;hello, world!&#039;)\n \n \ndef foo():\n    print(&#039;goodbye, world!&#039;)\n \n \n# 下面的代码会输出什么呢？\nfoo()\nPython中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数\nimport module1 as m1\nimport module2 as m2\n \nm1.foo()\nm2.foo()\n如果导入的模块除了定义函数之外还有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是”__main__”\ndef foo():\n    pass\n \n \ndef bar():\n    pass\n \n \n# __name__是Python中一个隐含的变量它代表了模块的名字\n# 只有被Python解释器直接执行的模块的名字才是__main__\nif __name__ == &#039;__main__&#039;:\n    print(&#039;call foo()&#039;)\n    foo()\n    print(&#039;call bar()&#039;)\n    bar()\n作用域\nPython查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索\ndef foo():\n    global a\n    a = 200\n    print(a)  # 200\n \n \nif __name__ == &#039;__main__&#039;:\n    a = 100\n    foo()\n    print(a)  # 200\n使用global关键字来指示函数中的变量来自于全局作用域，如果希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域，在实际开发中，应该尽量减少对全局变量的使用\n如果希望将一个局部变量的生命周期延长，使其在定义它的函数调用结束后依然可以使用它的值，这时候就需要使用闭包\n说明： 很多人经常会将“闭包”和“匿名函数”混为一谈，但实际上它们并不是一回事，如果想了解这个概念，可以看看维基百科的解释或者知乎上对这个概念的讨论\n字符串和常用数据结构\n数值类型是标量类型，也就是说这种类型的对象没有可以访问的内部结构；而字符串类型是一种结构化的、非标量类型，所以才会有一系列的属性和方法\n定义列表可以将列表的元素放在[]中，多个元素用,进行分隔，可以使用for循环对列表元素进行遍历，也可以使用[]或[:]运算符取出列表中的一个或多个元素\n生成式和生成器\nf = [x for x in range(1, 10)]\nprint(f)\nf = [x + y for x in &#039;ABCDE&#039; for y in &#039;1234567&#039;]\nprint(f)\n# 用列表的生成表达式语法创建列表容器\n# 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间\nf = [x ** 2 for x in range(1, 1000)]\nprint(sys.getsizeof(f))  # 查看对象占用内存的字节数\nprint(f)\n# 请注意下面的代码创建的不是一个列表而是一个生成器对象\n# 通过生成器可以获取到数据但它不占用额外的空间存储数据\n# 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)\nf = (x ** 2 for x in range(1, 1000))\nprint(sys.getsizeof(f))  # 相比生成式生成器不占用存储数据的空间\nprint(f)\nfor val in f:\n    print(val)\nPython中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数，示例斐波拉切数列的生成器\ndef fib(n):  \n    a, b = 0, 1  \n    for _ in range(n):  \n        a, b = b, a + b  \n        yield a  \n  \n  \ndef main():  \n    for val in fib(20):  \n        print(val)  \n  \n  \nif __name__ == &#039;__main__&#039;:  \n    main()  \n  \n# 执行结果  \n# n=0,a=0,b=1  \n# n=1,a=1,b=1  \n# n=2,a=1,b=2  \n# n=3,a=2,b=3  \n# n=4,a=3,b=5\n# ...\n当执行到 yield a 语句时，生成器函数会暂停执行，并将当前的 a 值作为生成的值返回给调用者。此时，生成器函数的状态被冻结，等待下一次调用。\n调用生成器函数时，会返回一个生成器对象。生成器对象可以被迭代，每次迭代时，生成器函数会从上一次暂停的位置继续执行，直到遇到下一个 yield 语句，然后再次暂停，将生成的值返回给调用者。\n元组\nPython中的元组与列表类似也是一种容器数据类型，可以用一个变量（对象）来存储多个数据，不同之处在于元组的元素不能修改\n# 定义元组\nt = (&#039;骆昊&#039;, 38, True, &#039;四川成都&#039;)\nprint(t)\n# 获取元组中的元素\nprint(t[0])\nprint(t[3])\n# 遍历元组中的值\nfor member in t:\n    print(member)\n# 重新给元组赋值\n# t[0] = &#039;王大锤&#039;  # TypeError: &#039;tuple&#039; object does not support item assignment\nt = (&#039;王大锤&#039;, 20, True, &#039;云南昆明&#039;) # 变量t重新引用了新的元组,原来的元组将被垃圾回收\nprint(t)\n# 将元组转换成列表\nperson = list(t)\nprint(person)\n# 列表是可以修改它的元素的\nperson[0] = &#039;李小龙&#039;\nperson[1] = 25\nprint(person)\n# 将列表转换成元组\nfruits_list = [&#039;apple&#039;, &#039;banana&#039;, &#039;orange&#039;]\nfruits_tuple = tuple(fruits_list)\nprint(fruits_tuple)\n集合\nPython中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算\n# 创建集合的字面量语法\nset1 = {1, 2, 3, 3, 3, 2}\nprint(set1)\nprint(&#039;Length =&#039;, len(set1))\n# 创建集合的构造器语法(面向对象部分会进行详细讲解)\nset2 = set(range(1, 10))\nset3 = set((1, 2, 3, 3, 2, 1))\nprint(set2, set3)\n# 创建集合的推导式语法(推导式也可以用于推导集合)\nset4 = {num for num in range(1, 100) if num % 3 == 0 or num % 5 == 0}\nprint(set4)\n字典\n字典是另一种可变容器模型，Python中的字典跟我们生活中使用的字典是一样一样的，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开\n# 创建字典的字面量语法\nscores = {&#039;骆昊&#039;: 95, &#039;白元芳&#039;: 78, &#039;狄仁杰&#039;: 82}\nprint(scores)\n# 创建字典的构造器语法\nitems1 = dict(one=1, two=2, three=3, four=4)\n# 通过zip函数将两个序列压成字典\nitems2 = dict(zip([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;], &#039;123&#039;))\n# 创建字典的推导式语法\nitems3 = {num: num ** 2 for num in range(1, 10)}\nprint(items1, items2, items3)\n# 通过键可以获取字典中对应的值\nprint(scores[&#039;骆昊&#039;])\nprint(scores[&#039;狄仁杰&#039;])\n# 对字典中所有键值对进行遍历\nfor key in scores:\n    print(f&#039;{key}: {scores[key]}&#039;)\n# 更新字典中的元素\nscores[&#039;白元芳&#039;] = 65\nscores[&#039;诸葛王朗&#039;] = 71\nscores.update(冷面=67, 方启鹤=85)\nprint(scores)\nif &#039;武则天&#039; in scores:\n    print(scores[&#039;武则天&#039;])\nprint(scores.get(&#039;武则天&#039;))\n# get方法也是通过键获取对应的值但是可以设置默认值\nprint(scores.get(&#039;武则天&#039;, 60))\n# 删除字典中的元素\nprint(scores.popitem())\nprint(scores.popitem())\nprint(scores.pop(&#039;骆昊&#039;, 100))\n# 清空字典\nscores.clear()\nprint(scores)\n面向对象基础\n把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派\n在Python中可以使用class关键字定义类，然后在类中通过函数来定义方法，这样就可以将对象的动态特征描述出来\n定义类\n在 Python 3.x 中，所有的类都默认继承自 object，无论是否显式地指定，这意味着在 Python 3.x 中，可以省略 object，因为它是默认的基类\nclass Student(object):\n\n    # __init__是一个特殊方法用于在创建对象时进行初始化操作\n    # 通过这个方法我们可以为学生对象绑定name和age两个属性\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def study(self, course_name):\n        print(&#039;%s正在学习%s.&#039; % (self.name, course_name))\n\n    # PEP 8要求标识符的名字用全小写多个单词用下划线连接\n    # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)\n    def watch_movie(self):\n        if self.age &lt; 18:\n            print(&#039;%s只能观看《熊出没》.&#039; % self.name)\n        else:\n            print(&#039;%s正在观看岛国爱情大电影.&#039; % self.name)\n\n说明： 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息\n创建使用\ndef main():\n    # 创建学生对象并指定姓名和年龄\n    stu1 = Student(&#039;骆昊&#039;, 38)\n    # 给对象发study消息\n    stu1.study(&#039;Python程序设计&#039;)\n    # 给对象发watch_av消息\n    stu1.watch_movie()\n    stu2 = Student(&#039;王大锤&#039;, 15)\n    stu2.study(&#039;思想品德&#039;)\n    stu2.watch_movie()\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n访问可见性\n在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头\nPython并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们\n面向对象支柱\n\n封装：将数据和对数据的操作封装在对象中，通过对象的方法来访问和修改数据\n继承：通过继承创建新的类，子类可以继承父类的属性和方法，并且可以覆盖或扩展它们\n多态：同一个方法可以在不同的对象上产生不同的行为\n\n面向对象进阶\n@property装饰器\n虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如没有办法检查赋给属性的值是否有效。之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便\nclass Person(object):\n\n    def __init__(self, name, age):\n        self._name = name\n        self._age = age\n\n    # 访问器 - getter方法\n    @property\n    def name(self):\n        return self._name\n\n    # 访问器 - getter方法\n    @property\n    def age(self):\n        return self._age\n\n    # 修改器 - setter方法\n    @age.setter\n    def age(self, age):\n        self._age = age\n\n    def play(self):\n        if self._age &lt;= 16:\n            print(&#039;%s正在玩飞行棋.&#039; % self._name)\n        else:\n            print(&#039;%s正在玩斗地主.&#039; % self._name)\n\n\ndef main():\n    person = Person(&#039;王大锤&#039;, 12)\n    person.play()\n    person.age = 22\n    person.play()\n    # person.name = &#039;白元芳&#039;  # AttributeError: can&#039;t set attribute\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n__slots__魔法\nPython是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用\nclass Person(object):\n\n    # 限定Person对象只能绑定_name, _age和_gender属性\n    __slots__ = (&#039;_name&#039;, &#039;_age&#039;, &#039;_gender&#039;)\n\n    def __init__(self, name, age):\n        self._name = name\n        self._age = age\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def age(self):\n        return self._age\n\n    @age.setter\n    def age(self, age):\n        self._age = age\n\n    def play(self):\n        if self._age &lt;= 16:\n            print(&#039;%s正在玩飞行棋.&#039; % self._name)\n        else:\n            print(&#039;%s正在玩斗地主.&#039; % self._name)\n\n\ndef main():\n    person = Person(&#039;王大锤&#039;, 22)\n    person.play()\n    person._gender = &#039;男&#039;\n    # AttributeError: &#039;Person&#039; object has no attribute &#039;_is_gay&#039;\n    # person._is_gay = True\n\n静态方法和类方法\n之前在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，写在类中的方法并不需要都是对象方法，例如定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。可以使用静态方法来解决这类问题\nfrom math import sqrt\n\n\nclass Triangle(object):\n\n    def __init__(self, a, b, c):\n        self._a = a\n        self._b = b\n        self._c = c\n\n    @staticmethod\n    def is_valid(a, b, c):\n        return a + b &gt; c and b + c &gt; a and a + c &gt; b\n\n    def perimeter(self):\n        return self._a + self._b + self._c\n\n    def area(self):\n        half = self.perimeter() / 2\n        return sqrt(half * (half - self._a) *\n                    (half - self._b) * (half - self._c))\n\n\ndef main():\n    a, b, c = 3, 4, 5\n    # 静态方法和类方法都是通过给类发消息来调用的\n    if Triangle.is_valid(a, b, c):\n        t = Triangle(a, b, c)\n        print(t.perimeter())\n        # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数\n        # print(Triangle.perimeter(t))\n        print(t.area())\n        # print(Triangle.area(t))\n    else:\n        print(&#039;无法构成三角形.&#039;)\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象\nfrom time import time, localtime, sleep\n\n\nclass Clock(object):\n    &quot;&quot;&quot;数字时钟&quot;&quot;&quot;\n\n    def __init__(self, hour=0, minute=0, second=0):\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n\n    @classmethod\n    def now(cls):\n        ctime = localtime(time())\n        return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)\n\n    def run(self):\n        &quot;&quot;&quot;走字&quot;&quot;&quot;\n        self._second += 1\n        if self._second == 60:\n            self._second = 0\n            self._minute += 1\n            if self._minute == 60:\n                self._minute = 0\n                self._hour += 1\n                if self._hour == 24:\n                    self._hour = 0\n\n    def show(self):\n        &quot;&quot;&quot;显示时间&quot;&quot;&quot;\n        return &#039;%02d:%02d:%02d&#039; % \\\n               (self._hour, self._minute, self._second)\n\n\ndef main():\n    # 通过类方法创建对象并获取系统时间\n    clock = Clock.now()\n    while True:\n        print(clock.show())\n        sleep(1)\n        clock.run()\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n类之间的关系\n简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系\n\nis-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系\nhas-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系\nuse-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系\n\n继承和多态\n可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则\nclass Person(object):\n    &quot;&quot;&quot;人&quot;&quot;&quot;\n\n    def __init__(self, name, age):\n        self._name = name\n        self._age = age\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def age(self):\n        return self._age\n\n    @age.setter\n    def age(self, age):\n        self._age = age\n\n    def play(self):\n        print(&#039;%s正在愉快的玩耍.&#039; % self._name)\n\n    def watch_av(self):\n        if self._age &gt;= 18:\n            print(&#039;%s正在观看爱情动作片.&#039; % self._name)\n        else:\n            print(&#039;%s只能观看《熊出没》.&#039; % self._name)\n\n\nclass Student(Person):\n    &quot;&quot;&quot;学生&quot;&quot;&quot;\n\n    def __init__(self, name, age, grade):\n        super().__init__(name, age)\n        self._grade = grade\n\n    @property\n    def grade(self):\n        return self._grade\n\n    @grade.setter\n    def grade(self, grade):\n        self._grade = grade\n\n    def study(self, course):\n        print(&#039;%s的%s正在学习%s.&#039; % (self._grade, self._name, course))\n\n\nclass Teacher(Person):\n    &quot;&quot;&quot;老师&quot;&quot;&quot;\n\n    def __init__(self, name, age, title):\n        super().__init__(name, age)\n        self._title = title\n\n    @property\n    def title(self):\n        return self._title\n\n    @title.setter\n    def title(self, title):\n        self._title = title\n\n    def teach(self, course):\n        print(&#039;%s%s正在讲%s.&#039; % (self._name, self._title, course))\n\n\ndef main():\n    stu = Student(&#039;王大锤&#039;, 15, &#039;初三&#039;)\n    stu.study(&#039;数学&#039;)\n    stu.watch_av()\n    t = Teacher(&#039;骆昊&#039;, 38, &#039;砖家&#039;)\n    t.teach(&#039;Python程序设计&#039;)\n    t.watch_av()\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）\nfrom abc import ABCMeta, abstractmethod\n\n\nclass Pet(object, metaclass=ABCMeta):\n    &quot;&quot;&quot;宠物&quot;&quot;&quot;\n\n    def __init__(self, nickname):\n        self._nickname = nickname\n\n    @abstractmethod\n    def make_voice(self):\n        &quot;&quot;&quot;发出声音&quot;&quot;&quot;\n        pass\n\n\nclass Dog(Pet):\n    &quot;&quot;&quot;狗&quot;&quot;&quot;\n\n    def make_voice(self):\n        print(&#039;%s: 汪汪汪...&#039; % self._nickname)\n\n\nclass Cat(Pet):\n    &quot;&quot;&quot;猫&quot;&quot;&quot;\n\n    def make_voice(self):\n        print(&#039;%s: 喵...喵...&#039; % self._nickname)\n\n\ndef main():\n    pets = [Dog(&#039;旺财&#039;), Cat(&#039;凯蒂&#039;), Dog(&#039;大黄&#039;)]\n    for pet in pets:\n        pet.make_voice()\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n在上面的代码中，将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）\n文件和异常\nPython内置的open函数，可以指定文件名、操作模式、编码信息等来获得操作文件的对象\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n操作模式具体含义&#039;r&#039;读取 （默认）&#039;w&#039;写入（会先截断之前的内容）&#039;x&#039;写入，如果文件已经存在会产生异常&#039;a&#039;追加，将内容写入到已有文件的末尾&#039;b&#039;二进制模式&#039;t&#039;文本模式（默认）&#039;+&#039;更新（既可以读又可以写）\ndef main():\n    f = None\n    try:\n        f = open(&#039;致橡树.txt&#039;, &#039;r&#039;, encoding=&#039;utf-8&#039;)\n        print(f.read())\n    except FileNotFoundError:\n        print(&#039;无法打开指定的文件!&#039;)\n    except LookupError:\n        print(&#039;指定了未知的编码!&#039;)\n    except UnicodeDecodeError:\n        print(&#039;读取文件时解码错误!&#039;)\n    finally:\n        if f:\n            f.close()\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n除了使用文件对象的read方法读取文件之外，还可以使用for-in循环逐行读取或者用readlines方法将文件按行读取到一个列表容器中\n字符串和正则\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n符号解释示例说明.匹配任意字符b.t可以匹配bat / but / b#t / b1t等\\w匹配字母/数字/下划线b\\wt可以匹配bat / b1t / b_t等  但不能匹配b#t\\s匹配空白字符（包括\\r、\\n、\\t等）love\\syou可以匹配love you\\d匹配数字\\d\\d可以匹配01 / 23 / 99等\\b匹配单词的边界\\bThe\\b^匹配字符串的开始^The可以匹配The开头的字符串$匹配字符串的结束.exe$可以匹配.exe结尾的字符串\\W匹配非字母/数字/下划线b\\Wt可以匹配b#t / b@t等  但不能匹配but / b1t / b_t等\\S匹配非空白字符love\\Syou可以匹配love#you等  但不能匹配love you\\D匹配非数字\\d\\D可以匹配9a / 3# / 0F等\\B匹配非单词边界\\Bio\\B[]匹配来自字符集的任意单一字符[aeiou]可以匹配任一元音字母字符[^]匹配不在字符集中的任意单一字符[^aeiou]可以匹配任一非元音字母字符*匹配0次或多次\\w*+匹配1次或多次\\w+?匹配0次或1次\\w?{N}匹配N次\\w{3}{M,}匹配至少M次\\w{3,}{M,N}匹配至少M次至多N次\\w{3,6}|分支foo|bar可以匹配foo或者bar(?#)注释(exp)匹配exp并捕获到自动命名的组中(?exp)匹配exp并捕获到名为name的组中(?:exp)匹配exp但是不捕获匹配的文本(?=exp)匹配exp前面的位置\\b\\w+(?=ing)可以匹配I’m dancing中的danc(?⇐exp)匹配exp后面的位置(?⇐\\bdanc)\\w+\\b可以匹配I love dancing and reading中的第一个ing(?!exp)匹配后面不是exp的位置(?&lt;!exp)匹配前面不是exp的位置*?重复任意次，但尽可能少重复a.b  a.?b将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串+?重复1次或多次，但尽可能少重复??重复0次或1次，但尽可能少重复{M,N}?重复M到N次，但尽可能少重复{M,}?重复M次以上，但尽可能少重复\npython对正则的支持\nPython提供了re模块来支持正则表达式相关操作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明compile(pattern, flags=0)编译正则表达式返回正则表达式对象match(pattern, string, flags=0)用正则表达式匹配字符串 成功返回匹配对象 否则返回Nonesearch(pattern, string, flags=0)搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回Nonesplit(pattern, string, maxsplit=0, flags=0)用正则表达式指定的模式分隔符拆分字符串 返回列表sub(pattern, repl, string, count=0, flags=0)用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数fullmatch(pattern, string, flags=0)match函数的完全匹配（从字符串开头到结尾）版本findall(pattern, string, flags=0)查找字符串所有与正则表达式匹配的模式 返回字符串的列表finditer(pattern, string, flags=0)查找字符串所有与正则表达式匹配的模式 返回一个迭代器purge()清除隐式编译的正则表达式的缓存re.I / re.IGNORECASE忽略大小写匹配标记re.M / re.MULTILINE多行匹配标记\n进程和线程\n进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间\n一个进程可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程\nPython既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程\n多进程\nUnix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。fork()函数非常特殊它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了fork()函数。由于Windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（Pool）、用于进程间通信的队列（Queue）和管道（Pipe）等\nfrom multiprocessing import Process\nfrom os import getpid\nfrom random import randint\nfrom time import time, sleep\n\n\ndef download_task(filename):\n    print(&#039;启动下载进程，进程号[%d].&#039; % getpid())\n    print(&#039;开始下载%s...&#039; % filename)\n    time_to_download = randint(5, 10)\n    sleep(time_to_download)\n    print(&#039;%s下载完成! 耗费了%d秒&#039; % (filename, time_to_download))\n\n\ndef main():\n    start = time()\n    p1 = Process(target=download_task, args=(&#039;Python从入门到住院.pdf&#039;, ))\n    p1.start()\n    p2 = Process(target=download_task, args=(&#039;Peking Hot.avi&#039;, ))\n    p2.start()\n    p1.join()\n    p2.join()\n    end = time()\n    print(&#039;总共耗费了%.2f秒.&#039; % (end - start))\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n上面的代码中，通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，而join方法表示等待进程执行结束，也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信\n多线程\n在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装\n可以直接使用threading模块的Thread类来创建线程，也可以从已有的类创建新类，通过继承Thread类的方式来创建自定义的线程类\nfrom random import randint\nfrom threading import Thread\nfrom time import time, sleep\n\n\nclass DownloadTask(Thread):\n\n    def __init__(self, filename):\n        super().__init__()\n        self._filename = filename\n\n    def run(self):\n        print(&#039;开始下载%s...&#039; % self._filename)\n        time_to_download = randint(5, 10)\n        sleep(time_to_download)\n        print(&#039;%s下载完成! 耗费了%d秒&#039; % (self._filename, time_to_download))\n\n\ndef main():\n    start = time()\n    t1 = DownloadTask(&#039;Python从入门到住院.pdf&#039;)\n    t1.start()\n    t2 = DownloadTask(&#039;Peking Hot.avi&#039;)\n    t2.start()\n    t1.join()\n    t2.join()\n    end = time()\n    print(&#039;总共耗费了%.2f秒.&#039; % (end - start))\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\n网络编程入门\n网络协议的三要素是：语法、语义和时序。构成我们今天使用的Internet的基础的是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，通常也把这套东西称为TCP/IP模型。与国际标准化组织发布的OSI/RM这个七层模型不同，TCP/IP是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层\nTCP全称传输控制协议\n\n数据不传丢不传错（利用握手、校验和重传机制可以实现）\n流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）\n拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）\n\n网络应用模式\n\nC/S模式和B/S模式。这里的C指的是Client（客户端），B指的是Browser（浏览器）\n去中心化的网络应用模式\n\n基于传输层协议的套接字编程\n套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用\nTCP套接字\n所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务\n一个提供时间日期的服务器\nfrom socket import socket, SOCK_STREAM, AF_INET\nfrom datetime import datetime\n\n\ndef main():\n    # 1.创建套接字对象并指定使用哪种传输服务\n    # family=AF_INET - IPv4地址\n    # family=AF_INET6 - IPv6地址\n    # type=SOCK_STREAM - TCP套接字\n    # type=SOCK_DGRAM - UDP套接字\n    # type=SOCK_RAW - 原始套接字\n    server = socket(family=AF_INET, type=SOCK_STREAM)\n    # 2.绑定IP地址和端口(端口用于区分不同的服务)\n    # 同一时间在同一个端口上只能绑定一个服务否则报错\n    server.bind((&#039;192.168.1.2&#039;, 6789))\n    # 3.开启监听 - 监听客户端连接到服务器\n    # 参数512可以理解为连接队列的大小\n    server.listen(512)\n    print(&#039;服务器启动开始监听...&#039;)\n    while True:\n        # 4.通过循环接收客户端的连接并作出相应的处理(提供服务)\n        # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行\n        # accept方法返回一个元组其中的第一个元素是客户端对象\n        # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成)\n        client, addr = server.accept()\n        print(str(addr) + &#039;连接到了服务器.&#039;)\n        # 5.发送数据\n        client.send(str(datetime.now()).encode(&#039;utf-8&#039;))\n        # 6.断开连接\n        client.close()\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\nfrom socket import socket\n\n\ndef main():\n    # 1.创建套接字对象默认使用IPv4和TCP协议\n    client = socket()\n    # 2.连接到服务器(需要指定IP地址和端口)\n    client.connect((&#039;192.168.1.2&#039;, 6789))\n    # 3.从服务器接收数据\n    print(client.recv(1024).decode(&#039;utf-8&#039;))\n    client.close()\n\n\nif __name__ == &#039;__main__&#039;:\n    main()\n\nUDP套接字\n传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的\n图像和文档处理\n用程序来处理图像和办公文档经常出现在实际开发中，Python的标准库中虽然没有直接支持这些操作的模块，但我们可以通过Python生态圈中的第三方模块来完成这些操作"},"基础技能/shell":{"title":"shell","links":[],"tags":["基础技能"],"content":""},"基础技能/vue":{"title":"vue","links":[],"tags":["基础技能"],"content":"安装nodejs\n下载地址 Node.js 中文网 (nodejs.com.cn)\nnodejs安装步骤 Installation · nodejs/help Wiki (github.com)\nlinux安装nodejs参考命令\n[root@ctl01 tmp]# tar -xf node-v18.19.0-linux-x64.tar.xz\n[root@ctl01 tmp]# mv node-v18.19.0-linux-x64 nodejs\n[root@ctl01 tmp]# mv nodejs /usr/local/\n[root@ctl01 tmp]# echo &quot;export PATH=$PATH:/usr/local/nodejs/bin&quot; &gt;&gt; /etc/profile\n[root@ctl01 tmp]# source /etc/profile\n证书过期处理\n# vue创建项目报错\n$ error An unexpected error occurred: &quot;https://registry.npm.taobao.org/@vue%2fcli-plugin-babel: certificate has expired&quot;.\n# 首先更换镜像地址\n$ npm config set registry https://registry.npmmirror.com\n# 调整用户目录下配置\n$ cat .vuerc\n{\n  &quot;useTaobaoRegistry&quot;: false,#如果为true调整为false，如果为false调整为true\n  &quot;packageManager&quot;: &quot;yarn&quot;\n}"},"基础技能/基础技能":{"title":"基础技能","links":[],"tags":[],"content":"\n\n基础技能\n\n操作系统（如 Linux、Unix、Windows）的基本原理和命令行操作\n网络协议和网络基础知识\n编程基础（如 Python、Shell、Perl）\n\n\n"},"安全和权限管理/ssh免密登录":{"title":"ssh免密登录","links":[],"tags":["安全和权限管理"],"content":"示例 A为本地主机，BC为远程服务器\n使用ssh-keygen生成密钥对\nssh-keygen\n拷贝生成的公钥到远程服务器BC，即可在本地主机免密登录远程服务器BC\nssh-copy-id -i ~/.ssh/xxx.pub user@server\n示例\n[root@ctl01 ~]# ssh-copy-id -i .ssh/id_rsa.pub root@10.191.101.128\n/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;.ssh/id_rsa.pub&quot;\nThe authenticity of host &#039;10.191.101.128 (10.191.101.128)&#039; can&#039;t be established.\nECDSA key fingerprint is SHA256:kcGPeZqN7kwKRmmDpg/O3mBazd+psSvHODd8bfUdi6Y.\nECDSA key fingerprint is MD5:e5:b9:be:58:c7:f1:12:bd:66:87:af:94:51:3b:5f:e8.\nAre you sure you want to continue connecting (yes/no)? yes\n/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed\n/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys\nroot@10.191.101.128&#039;s password:\n \nNumber of key(s) added: 1\n \nNow try logging into the machine, with:   &quot;ssh &#039;root@10.191.101.128&#039;&quot;\nand check to make sure that only the key(s) you wanted were added.\n通俗的理解，在ssh免密登录过程中，“我”生成一对钥匙（私钥）和锁（公钥），将锁分发给其他人，需要时用来锁住必要数据，而只有“我”的钥匙能够打开，以此建立安全连接"},"安全和权限管理/公钥与私钥":{"title":"公钥与私钥","links":["安全和权限管理/ssh免密登录"],"tags":["安全和权限管理"],"content":"散列算法\n散列算法，也叫做哈希函数，有时候也叫做摘要算法，常用的算法有：MD5 SHA1\nMD5\nMD5 不是一种加密算法，是一种摘要算法，无论多长的输入，MD5 都会输出长度为 128bits 的一个串\nSHA1\nSHA1 算法也是一个摘要算法， SHA1 比 MD5 更加安全，对于长度小于 2^64 位的消息，SHA1 会产生一个 160 位的消息摘要\n摘要算法有摘要特性和不可逆特性，一般用于检查文件的完整性和数据签名的场景\n加密算法\n对称加密\n加、解密使用的是同一串秘钥，只有一个秘钥作为私钥\n常用算法：DES、3DES、Blowfish、IDEA、RC4、RC5、RC6和AES\n非对称加密\n加、解密使用不同秘钥，通常一对私钥与公钥，公钥加密，私钥解密，亦可私钥加密公钥解密），通常加密指代前者，后者叫做“签名”\n常用算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）\nssh免密登录\n编码算法\nBase64\n编码算法，将任意二进制编码成文本"},"安全和权限管理/安全和权限管理":{"title":"安全和权限管理","links":[],"tags":[],"content":"\n\n安全和权限管理\n\n系统安全和漏洞管理\n访问控制和权限管理（如 LDAP、RBAC）\n防火墙和网络安全配置\n\n\n"},"应用部署和容灾/应用部署和容灾":{"title":"应用部署和容灾","links":[],"tags":[],"content":"\n\n应用部署和容灾\n\nWeb 服务器和应用服务器的部署和配置（如 Nginx、Apache、Tomcat）\n高可用性和容灾技术（如负载均衡、故障转移、备份恢复）\n\n\n"},"故障排除和性能优化/mysql":{"title":"mysql","links":[],"tags":["故障排除和性能优化"],"content":"数据库断电无法重启\n报错内容\n[root@ctl01 ~]# more /var/log/mariadb/mariadb.log\n2024-03-13 11:23:59 0 [Note] InnoDB: Using Linux native AIO\n2024-03-13 11:23:59 0 [Note] InnoDB: Mutexes and rw_locks use GCC atomic builtins\n2024-03-13 11:23:59 0 [Note] InnoDB: Uses event mutexes\n2024-03-13 11:23:59 0 [Note] InnoDB: Compressed tables use zlib 1.2.7\n2024-03-13 11:23:59 0 [Note] InnoDB: Number of pools: 1\n2024-03-13 11:23:59 0 [Note] InnoDB: Using SSE2 crc32 instructions\n2024-03-13 11:23:59 0 [Note] InnoDB: Initializing buffer pool, total size = 128M, instances = 1, chunk size = 128M\n2024-03-13 11:23:59 0 [Note] InnoDB: Completed initialization of buffer pool\n2024-03-13 11:24:00 0 [Note] InnoDB: If the mysqld execution user is authorized, page cleaner thread priority can be changed. See the man page of\n setpriority().\n2024-03-13 11:24:00 0 [ERROR] InnoDB: Missing MLOG_CHECKPOINT at 135649212 between the checkpoint 135649212 and the end 135648768.\n2024-03-13 11:24:00 0 [ERROR] InnoDB: Plugin initialization aborted with error Generic error\n2024-03-13 11:24:00 0 [Note] InnoDB: Starting shutdown...\n2024-03-13 11:24:00 0 [ERROR] Plugin &#039;InnoDB&#039; init function returned error.\n2024-03-13 11:24:00 0 [ERROR] Plugin &#039;InnoDB&#039; registration as a STORAGE ENGINE failed.\n2024-03-13 11:24:00 0 [Note] Plugin &#039;FEEDBACK&#039; is disabled.\n2024-03-13 11:24:00 0 [ERROR] Unknown/unsupported storage engine: innodb\n2024-03-13 11:24:00 0 [ERROR] Aborting\n问题解决，尝试以下几点：\n\n在主从上设置innodb_log_checksums = ON\n删除rm /var/lib/mysql/ib_logfile*\n重新启动\n"},"故障排除和性能优化/故障排除和性能优化":{"title":"故障排除和性能优化","links":[],"tags":[],"content":"\n\n故障排除和性能优化\n\n系统故障排查和调优\n性能监测和性能优化技术\n容量规划和资源管理\n\n\n"},"文档和沟通能力/文档和沟通能力":{"title":"文档和沟通能力","links":[],"tags":[],"content":"\n\n文档和沟通能力\n\n技术文档编写和维护\n团队协作和沟通能力\n问题解决和故障处理技巧\n\n\n"},"监控和日志管理/监控和日志管理":{"title":"监控和日志管理","links":[],"tags":[],"content":"\n\n监控和日志管理\n\n监控系统的搭建和配置（如 Zabbix、Prometheus）\n日志管理和分析工具（如 ELK Stack、Splunk）\n\n\n"},"网络和存储管理/mysql":{"title":"mysql","links":[],"tags":["网络和存储管理"],"content":""},"网络和存储管理/pgsql":{"title":"pgsql","links":[],"tags":["网络和存储管理"],"content":""},"网络和存储管理/网络和存储管理":{"title":"网络和存储管理","links":[],"tags":[],"content":"\n\n网络和存储管理\n\n网络设备的配置和管理\n存储管理和数据备份策略\n数据库管理（如 MySQL、PostgreSQL、MongoDB）\n\n\n"},"自动化和编程/Jinja2":{"title":"jinja2","links":[],"tags":[],"content":"特点\n\n\n语法简洁：Jinja2使用简洁而易读的语法，使用大括号{{ }}表示变量插值，使用{% %}表示控制流语句（如条件和循环），以及使用{# #}表示注释\n\n\n变量插值：Jinja2允许在模板中插入变量的值。可以将变量直接插入到模板中，或者使用过滤器对变量进行处理和格式化\n\n\n控制流语句：Jinja2支持条件语句（如if、else、elif）和循环语句（如for、while）。这些语句允许根据条件或迭代集合来控制模板的输出\n\n\n模板继承：Jinja2支持模板继承，可以定义一个基础模板（父模板），然后在派生模板（子模板）中根据需要重写和扩展父模板的内容\n\n\n过滤器和函数：Jinja2提供了多个内置过滤器和函数，用于对变量进行处理和转换。可以使用这些过滤器和函数对变量进行格式化、截取、排序等操作\n\n\n宏（Macro）：宏是一种用于定义可重用代码块的机制。可以使用宏来定义一段代码，并在模板的其他地方多次调用该代码块\n\n\n自定义扩展：Jinja2允许开发者自定义扩展，以增加额外的功能和语法。可以编写自定义过滤器、函数、测试等，以满足特定的需求\n\n"},"自动化和编程/ansible":{"title":"ansible","links":["自动化和编程/jinja2"],"tags":["自动化和编程"],"content":"简介\n基于Python开源的自动化工具，用于配置管理、部署、编排和远程执行任务，它使用SSH协议进行通信，由Paramiko（Python库）、 PyYAML和Jinja2 ( 模板化 ) 三个关键模块实现，并使用基于YAML的描述文件来定义任务和配置\n特性\n\n模块化\n无客户端\n主从模式\n幂等性\n\n关键参数\n\n\n主机清单（Inventory）：主机清单是一个YAML或INI格式的文件，用于定义受管理的主机和主机组。它指定了Ansible将在哪些主机上执行任务\n\n\n模块（Module）：模块是Ansible的基本执行单元，用于在目标主机上执行特定的任务。Ansible提供了丰富的模块库，包括文件操作、软件包管理、用户管理等各种功能\n\n\nPlaybook（剧本）：Playbook是一个YAML格式的文件，用于定义一系列任务和配置的顺序。它描述了Ansible在目标主机上执行的操作流程，包括主机选择、任务执行和变量设置等\n\n\n角色（Role）：角色是一种组织和复用任务和配置的方法。它将相关的任务、变量和文件组织在一起，以便在多个Playbook中重复使用\n\n\n变量（Variable）：变量用于存储和传递数据，在Playbook中可以使用变量来实现灵活的配置。变量可以在主机清单、Playbook和角色中定义，并可以通过模板或命令行参数进行动态设置\n\n\nHandlers：Handlers是一种特殊的任务，它用于响应其他任务的状态变化。当某个任务发生变化时，Handlers可以触发相应的操作，如重新启动服务、重新加载配置等\n\n\n模板（Template）：模板是一种用于生成配置文件的机制。Ansible使用jinja2模板引擎，可以在模板中使用变量和条件语句来动态生成配置文件\n\n\nVault：Vault用于安全地存储敏感信息，如密码和密钥。它可以加密和解密Ansible的变量文件，以防止敏感信息泄露\n\n\n开始\n[root@localhost ~]# ansible localhost -m command -a &#039;echo hello world!&#039;\nlocalhost | CHANGED | rc=0 &gt;&gt;\nhello world!\nAd-Hoc command\n简短地指令，指令操作模式\n[root@localhost ansible]# ansible local -m ping\n10.191.101.254 | SUCCESS =&gt; {\n    &quot;ansible_facts&quot;: {\n        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;\n    },\n    &quot;changed&quot;: false,\n    &quot;ping&quot;: &quot;pong&quot;\n}\nAd-Hoc commands 一次只能处理一件事情，这即是它与 Playbooks 最大的差异\nPlaybook\n剧本，可以通过事先写好的剧本 (Playbooks)来让各个被控节点进行指定的动作 (Plays) 和任务 (Tasks)\n[root@localhost ansible]# ansible-playbook playbooks/main.yml\n\nPLAY [Test] *************************************************************************************************************************************\n\nTASK [Gathering Facts] **************************************************************************************************************************\nok: [10.191.101.254]\n\nTASK [Hello world] ******************************************************************************************************************************\nchanged: [10.191.101.254]\n\nTASK [Print stdout] *****************************************************************************************************************************\nok: [10.191.101.254] =&gt; {\n    &quot;msg&quot;: &quot;&quot;\n}\n\nPLAY RECAP **************************************************************************************************************************************\n10.191.101.254             : ok=3    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\n\nPlay、task与Module\n\nPlay：通常为某个特定的目的，例如：\n\nSetup a official website with Drupal (借由 Drupal 建置官网)\nRestart the API service (重开 API 服务)\n\n\nTask：是要实行 Play 这个目地所需做的每个步骤，例如：\n\nInstall the Nginx (安裝 Nginx)\nKill the djnago process (强制停止 django 的行程)\n\n\nModule：Ansible 所提供的各种操作方法，例如：\n\napt: name=vim state=present (使用 apt 套件安装 vim)\ncommand: /sbin/shutdown -r now (使用 shutdown 的指令重新开机)\n\n\n"},"自动化和编程/git":{"title":"git","links":[],"tags":["自动化和编程"],"content":"拉取全部信息\ngit fetch -a\n切换到上一个分支\ngit checkout -\n内容比较\n比较工作区和暂存区不同\ngit diff\n比较两个 commit 之间的文件变动\ngit diff &lt;commit-id&gt; &lt;commit-id&gt;\n查看所有分支\ngit ls-remote --heads ssh://git@10.254.180.148:20495/PZCPHPT.ZDHBS/auto_upgrade_script.git\n克隆最近一次提交\ngit clone --depth=1 ssh://git@10.254.180.148:20495/PZCPHPT.ZDHBS/auto_upgrade_script.git\n配置用户名、邮箱\ngit config --global user.name chyuhung\ngit config --global user.email 977599667@qq.com\n回到远程仓库状态\n硬重置本地，将当前分支重置到远程仓库中 origin 的 dev 分支的最新提交\ngit reset --hard origin/dev\n大仓库拉取\n拉取最近一次\n1、拉取指定分支\ngit clone -b dev ssh://git@xxxx/xxxx/auto_deploy_script.git\n2、指定分支并只拉取最近一次提交\ngit clone -b dev --depth=1 ssh://git@xxxx/xxxx/auto_upgrade_script.git\n新建空仓库拉取\n1、本地直接新建对应仓库\nmkdir &lt;repo名称&gt;\n2、初始化git仓库（即新建.git/）\ngit init\n3、配置remote origin\ngit remote add origin &lt;repo地址&gt;\n4、新建待拉取对应分支（默认为master）\ngit checkout -b &lt;对应分支名&gt;\n5、拉取特定分支\ngit pull origin &lt;对应分支名&gt;\n分支合并\n1、切换到特定分支并拉取最新代码，完成相关代码修改提交\ngit checkout feature-compmgmt1015\ngit pull\n2、切换到主分支，拉取最新代码\ngit  checkout dev\ngit pull\n3、合并代码到主分支\ngit merge feature-compmgmt1015\n# 解决有合并冲突的文件\n# git restore &lt;非我们改动的文件&gt;\n# git add . &amp;&amp; git commit -m &#039;解决有合并冲突的文件&#039;\ngit push\n4、查看git日志\ngit log\n5、恢复文件\ngit restore --staged .\ngit restore  .\n6、显示指定commit修改内容\ngit show 685b7067992b4ee1230fe38cc1c9dec2beb60e55\ngit status\n分支跟踪\n设置本地dev分支跟踪远程dev分支\n$ git remote -v\norigin  ssh://git@xxxx/xxxx/auto_upgrade_script.git (fetch)\norigin  ssh://git@xxxx/xxxx/auto_upgrade_script.git (push)\n \n$ git checkout dev\nSwitched to branch &#039;dev&#039;\n \n$  git branch --set-upstream-to=origin/dev dev\nbranch &#039;dev&#039; set up to track &#039;origin/dev&#039;."},"自动化和编程/github-actions":{"title":"github actions","links":[],"tags":["自动化和编程"],"content":""},"自动化和编程/自动化和编程":{"title":"自动化和编程","links":[],"tags":[],"content":"\n\n自动化和编程\n\n自动化工具（如 Ansible、Chef、Puppet）\n脚本编程和编写自动化脚本\n版本控制系统（如 Git、SVN）\n\n\n"}}